diff --git a/lib/CodeGen/IdemRegRename/IdemRegisterRenaming2.cpp b/lib/CodeGen/IdemRegRename/IdemRegisterRenaming2.cpp
index 7790c5e..4c20600 100644
--- a/lib/CodeGen/IdemRegRename/IdemRegisterRenaming2.cpp
+++ b/lib/CodeGen/IdemRegRename/IdemRegisterRenaming2.cpp
@@ -110,7 +110,6 @@ public:
   }
 
 private:
-  inline void collectLiveInRegistersForRegions();
   void computeAntiDependenceSet();
   void gatherAntiDeps(MachineInstr *idem);
   bool handleAntiDependences();
@@ -128,7 +127,7 @@ private:
 
   bool isTwoAddressInstr(MachineInstr *useMI);
 
-  void spillCurrentUse(AntiDeps &ad);
+  void spillCurrentUse(AntiDeps &pair);
 
   unsigned choosePhysRegForRenaming(MachineOperand *use,
                                     LiveIntervalIdem *interval,
@@ -163,6 +162,13 @@ private:
                        std::vector<MIOp> &usesAndDefs,
                        bool &canReplace);
 
+  void getUsesSetOfDef(unsigned reg,
+                       MachineBasicBlock::iterator begin,
+                       MachineBasicBlock::iterator end,
+                       MachineBasicBlock *mbb,
+                       std::set<MachineBasicBlock *> &visited,
+                       std::vector<MIOp> &usesAndDefs);
+
   unsigned getFreeRegisterForRenaming(unsigned useReg,
                                       LiveIntervalIdem *interval,
                                       DenseSet<unsigned> unallocableRegs);
@@ -206,6 +212,8 @@ private:
                         MachineBasicBlock *mbb,
                         std::set<MachineBasicBlock *> &visited);
 
+  void handleAntiDepWithoutUses(AntiDeps &pair);
+
 private:
   const TargetInstrInfo *tii;
   const TargetRegisterInfo *tri;
@@ -235,10 +243,6 @@ FunctionPass *llvm::createIdemRegisterRenamerPass() {
   return new IdemRegisterRenamer();
 }
 
-void IdemRegisterRenamer::collectLiveInRegistersForRegions() {
-  gather->run();
-}
-
 LLVM_ATTRIBUTE_UNUSED static bool contains(std::vector<MIOp> &set, unsigned reg) {
   for (auto &mo : set)
     if (mo.mi->getOperand(mo.index).getReg() == reg)
@@ -287,6 +291,7 @@ void IdemRegisterRenamer::collectAntiDepsTrace(unsigned reg,
     if (tii->isIdemBoundary(itr))
       return;
 
+    itr->dump();
     // iterate over operands from right to left, which means cope with
     // use oprs firstly, then def regs.
     for (int i = itr->getNumOperands() - 1; i >= 0; i--) {
@@ -327,6 +332,13 @@ void IdemRegisterRenamer::gatherAntiDeps(MachineInstr *idem) {
   if (liveIns.empty())
     return;
 
+  if (idem->getParent()->getName() == "for.body53") {
+    for (auto reg : liveIns) {
+      llvm::errs() << tri->getName(reg)<<" ";
+    }
+    llvm::errs()<<"\n";
+  }
+
   auto begin = ++MachineBasicBlock::iterator(idem);
   for (auto reg : liveIns) {
     // for an iteration of each live-in register, renew the visited set.
@@ -998,6 +1010,45 @@ void IdemRegisterRenamer::getUsesSetOfDef(MachineOperand *def,
       mbb->end(), mbb, visited, usesAndDefs, canReplace, false);
 }
 
+void IdemRegisterRenamer::getUsesSetOfDef(unsigned reg,
+                                          MachineBasicBlock::iterator begin,
+                                          MachineBasicBlock::iterator end,
+                                          MachineBasicBlock *mbb,
+                                          std::set<MachineBasicBlock *> &visited,
+                                          std::vector<MIOp> &usesAndDefs) {
+  if (!mbb)
+    return;
+  if (!visited.insert(mbb).second)
+    return;
+
+  for (; begin != end; ++begin) {
+    const auto &mi = begin;
+    if (tii->isIdemBoundary(mi)) {
+      return;
+    }
+
+    // when walk through operands, use opr first!
+    for (int i = mi->getNumOperands() - 1; i >= 0; i--) {
+      auto mo = mi->getOperand(i);
+      if (!mo.isReg() || !mo.getReg() || mo.getReg() != reg)
+        continue;
+        usesAndDefs.push_back(MIOp(mi, i));
+    }
+  }
+
+  if (!mbb->succ_empty()) {
+    for (auto succ = mbb->succ_begin(), succEnd = mbb->succ_end(); succ != succEnd; ++succ) {
+      getUsesSetOfDef(reg,
+                      (*succ)->begin(),
+                      (*succ)->end(),
+                      *succ,
+                      visited,
+                      usesAndDefs);
+    }
+  }
+}
+
+
 void IdemRegisterRenamer::collectUnallocableRegs(MachineBasicBlock::reverse_iterator begin,
                                                  MachineBasicBlock::reverse_iterator end,
                                                  MachineBasicBlock *mbb,
@@ -1152,6 +1203,152 @@ bool IdemRegisterRenamer::willRaiseAntiDep(unsigned useReg,
   return false;
 }
 
+void IdemRegisterRenamer::handleAntiDepWithoutUses(AntiDeps &pair) {
+  // Firstly, try to rename if possible. If can not do that, spill out it!
+  std::vector<IdempotentRegion*> regions;
+  auto &useMO = pair.uses.front();
+
+  mir->getRegionsContaining(*useMO.mi, &regions);
+
+  // get the last insertion position of previous adjacent region
+  // or the position of prior instruction depends on if the current instr
+  // is a two address instr.
+  bool twoAddrInstExits = isTwoAddressInstr(pair.uses.back().mi);
+
+  // Try to replace the old register name with other register to reduce
+  // inserted move instruction.
+  // If we can not find such register, than alter to insert move.
+
+  // We just count on such situation that all uses are within the same region
+  // as the current region.
+  std::vector<MIOp> usesAndDef;
+  bool canReplace = false;
+  auto &miLastDef = pair.defs.back();
+  getUsesSetOfDef(&miLastDef.mi->getOperand(miLastDef.index), usesAndDef, canReplace);
+
+  auto saved = miLastDef.mi;
+  std::set<MachineBasicBlock*> visited;
+  if (canReplace)
+    willRenameCauseOtherAntiDep(++saved, miLastDef.mi->getParent()->end(),
+                                miLastDef.mi->getParent(), pair.reg, visited, canReplace);
+
+  // If the current reg is used in ret instr, we can't replace it.
+  if (!twoAddrInstExits && canReplace) {
+    // We don't replace the name of R0 in ARM and x86 architecture.
+    // Because R0 is implicitly used by return instr.
+
+    MachineInstr *mostFarawayMI = nullptr;
+    for (auto &mo : usesAndDef) {
+      if (!mostFarawayMI || (&*mo.mi != mostFarawayMI &&
+          li->getIndex(mo.mi) > li->getIndex(mostFarawayMI)))
+        mostFarawayMI = mo.mi;
+    }
+
+    // If the last def don't have any uses
+    if (usesAndDef.empty()) {
+      auto mbb = miLastDef.mi->getParent();
+      mostFarawayMI = &mbb->back();
+      std::vector<MachineBasicBlock*> worklist;
+      visited.clear();
+      std::for_each(mbb->succ_begin(), mbb->succ_end(), [&](MachineBasicBlock *succ) {
+        worklist.push_back(succ);
+      });
+
+      while (!worklist.empty()) {
+        mbb = worklist.back();
+        worklist.pop_back();
+        if (!visited.insert(mbb).second)
+          continue;
+
+        if (!mbb->empty()) {
+          if (li->getIndex(&mbb->back()) > li->getIndex(mostFarawayMI))
+            mostFarawayMI = &mbb->back();
+        }
+        std::for_each(mbb->succ_begin(), mbb->succ_end(), [&](MachineBasicBlock *succ) {
+          worklist.push_back(succ);
+        });
+      }
+    }
+
+    assert(mostFarawayMI);
+
+    auto miDef = pair.defs.front();
+    unsigned from = li->getIndex(miDef.mi);
+    unsigned to = li->getIndex(mostFarawayMI);
+
+    unsigned phyReg = 0;
+    {
+      LiveIntervalIdem itrvl;
+
+      // indicates this interval should not be spilled out into memory.
+      itrvl.costToSpill = UINT32_MAX;
+      std::vector<MIOp> temps;
+      temps.assign(pair.defs.begin(), pair.defs.end());
+
+      itrvl.addRange(from, to);
+      for (auto &op : temps) {
+        MachineInstr *mi = op.mi;
+        /*mi->dump();*/
+        itrvl.usePoints.insert(UsePoint(li->getIndex(mi), &mi->getOperand(op.index)));
+      }
+
+      for (auto &op : usesAndDef) {
+        MachineInstr *mi = op.mi;
+        itrvl.usePoints.insert(UsePoint(li->getIndex(mi), &mi->getOperand(op.index)));
+      }
+
+      DenseSet<unsigned> unallocableRegs;
+      unallocableRegs.insert(pair.reg);
+      for (auto &r : regions) {
+        set_union(unallocableRegs, gather->getIdemLiveIns(&r->getEntry()));
+      }
+
+      phyReg = getFreeRegisterForRenaming(pair.reg, &itrvl, unallocableRegs);
+    }
+
+    if (phyReg != 0) {
+      // We have found a free register can be used for replacing the clobber register.
+      std::for_each(pair.defs.begin(), pair.defs.end(), [=](MIOp &op) {
+        op.mi->getOperand(op.index).setReg(phyReg);
+      });
+      std::for_each(usesAndDef.begin(), usesAndDef.end(), [=](MIOp &mo) {
+        mo.mi->getOperand(mo.index).setReg(phyReg);
+      });
+
+      // FIXME There are little problem, add this interval into LiveIntervalAnalysisIdem
+      // Finish replacing, skip following inserting move instr.
+      li->releaseMemory();
+      li->runOnMachineFunction(*mf);
+
+      // Before:
+      // 	IDEM
+      //  R0 = R0 + R1
+      //  R0 = R0 + 1
+      //  ret R0
+      //
+      // After:
+      // 	IDEM
+      //  R2 = R0 + R1
+      //  R0 = R2 + 1
+      //  ret R0
+      //
+      // The anti-dependence on R0 also remains.
+      unsigned oldReg = pair.reg;
+      for (auto &r : regions) {
+        auto begin = ++MachineBasicBlock::iterator(r->getEntry());
+        collectAntiDepsTrace(oldReg, begin, r->getEntry().getParent()->end(),
+                             r->getEntry().getParent(),
+                             std::vector<MIOp>(),
+                             std::vector<MIOp>());
+      }
+      return;
+    }
+  }
+
+  // Otherwise, spill it out.
+  spillCurrentUse(pair);
+}
+
 bool IdemRegisterRenamer::handleAntiDependences() {
   if (antiDeps.empty())
     return false;
@@ -1162,13 +1359,13 @@ bool IdemRegisterRenamer::handleAntiDependences() {
     auto pair = antiDeps.front();
     antiDeps.erase(antiDeps.begin());
 
-    if (pair.uses.empty() || pair.defs.empty())
+    assert(!pair.defs.empty() && "Those anti-dep without redefs shouldn't be counted as anti-dep!");
+    if (pair.uses.empty()) {
+      handleAntiDepWithoutUses(pair);
       continue;
+    }
 
     auto &useMO = pair.uses.front();
-    if (antiDeps.empty()) {
-      useMO.mi->dump();
-    }
     mir->getRegionsContaining(*useMO.mi, &regions);
 
     // get the last insertion position of previous adjacent region
@@ -1307,9 +1504,9 @@ bool IdemRegisterRenamer::handleAntiDependences() {
     }
 
     // get the free register
-    unsigned phyReg = 0;
+    //unsigned phyReg = 0;
 
-    if (!twoAddrInstExits || pair.uses.size() > 1) {
+    /*if (!twoAddrInstExits || pair.uses.size() > 1)*/ {
       if (regions.empty())
         continue;
 
@@ -1324,36 +1521,35 @@ bool IdemRegisterRenamer::handleAntiDependences() {
       // R0, ... = LDR_INC R0  (two address instr)
       // we should insert a special move instr for two address instr.
       MachineInstr *insertedPos = nullptr;
-      unsigned minIndex = UINT32_MAX;
-      insertedPos = nullptr;
-      auto &useMO = pair.uses.front();
+      //unsigned minIndex = UINT32_MAX;
+      //auto &useMO = pair.uses.front();
       unsigned phyReg = 0;
       DenseSet<unsigned> unallocableRegs;
 
       for (auto r : regions) {
         MachineInstr &idem = r->getEntry();
         set_union(unallocableRegs, gather->getIdemLiveIns(&idem));
-        auto begin = MachineBasicBlock::reverse_iterator(idem);
+        /*auto begin = MachineBasicBlock::reverse_iterator(idem);
         visited.clear();
         collectUnallocableRegs(begin, idem.getParent()->rend(),
-            idem.getParent(), visited, unallocableRegs);
+            idem.getParent(), visited, unallocableRegs);*/
 
-        unsigned index = li->getIndex(&idem);
+        /*unsigned index = li->getIndex(&idem);
         if (index < minIndex) {
           minIndex = index;
           insertedPos = &idem;
-        }
+        }*/
       }
 
       // can not assign the old register to use mi
       unallocableRegs.insert(pair.reg);
-      std::for_each(pair.uses.begin(), pair.uses.end(), [&](MIOp &op) {
+      /*std::for_each(pair.uses.begin(), pair.uses.end(), [&](MIOp &op) {
         MachineInstr *useMI = op.mi;
         for (unsigned i = 0, e = useMI->getNumOperands(); i < e; i++)
           if (useMI->getOperand(i).isReg() && useMI->getOperand(i).getReg() &&
               useMI->getOperand(i).isDef())
             unallocableRegs.insert(useMI->getOperand(i).getReg());
-      });
+      });*/
 
       /**
        * Avoiding repeatedly erase and add anti-dependence like following example.
@@ -1371,7 +1567,27 @@ bool IdemRegisterRenamer::handleAntiDependences() {
        *
        * It will repeat the process, we should avoid that situation.
        */
-      auto miOp = pair.uses.front();
+      insertedPos = useMO.mi;
+      std::vector<MIOp> usesAndDef;
+      auto &miLastDef = pair.defs.back();
+
+      auto mbb = miLastDef.mi->getParent();
+      visited.clear();
+      getUsesSetOfDef(pair.reg, ++MachineBasicBlock::iterator(miLastDef.mi),
+          mbb->end(), mbb, visited, usesAndDef);
+
+      MachineInstr* lastMI = usesAndDef.back().mi;
+      auto from = li->getIndex(useMO.mi) - 2;
+      auto to = li->getIndex(lastMI);
+
+      LiveIntervalIdem interval;
+      // indicates this interval should not be spilled out into memory.
+      interval.costToSpill = UINT32_MAX;
+
+      interval.addRange(from, to);    // add an interval for a temporal move instr.
+      phyReg = choosePhysRegForRenaming(&useMO.mi->getOperand(useMO.index), &interval, unallocableRegs);
+
+      /*auto miOp = pair.uses.front();
 
       do {
         if (shouldSpillCurrent(pair, unallocableRegs, regions)) {
@@ -1399,7 +1615,7 @@ bool IdemRegisterRenamer::handleAntiDependences() {
           break;
 
         unallocableRegs.insert(phyReg);
-      }while (true);
+      }while (true);*/
 
       if (!phyReg) {
         spillCurrentUse(pair);
@@ -1412,17 +1628,38 @@ bool IdemRegisterRenamer::handleAntiDependences() {
       // li->intervals.insert(std::make_pair(phyReg, interval));
 
       assert(TargetRegisterInfo::isPhysicalRegister(phyReg));
-      miOp = pair.uses.back();
-      unsigned oldReg = miOp.mi->getOperand(miOp.index).getReg();
+      unsigned oldReg = useMO.mi->getOperand(useMO.index).getReg();
       assert(phyReg != oldReg);
 
       // If there is two addr instr exists in the end of uses list, we just skip it.
-      size_t e = pair.uses.size() - twoAddrInstExits;
+      /*size_t e = pair.uses.size() - twoAddrInstExits;
       for (size_t i = 0; i < e; i++)
         pair.uses[i].mi->getOperand(pair.uses[i].index).setReg(phyReg);
 
       tii->copyPhysReg(*insertedPos->getParent(), insertedPos, DebugLoc(), phyReg, oldReg,
-                       miOp.mi->getOperand(miOp.index).isKill());
+                       miOp.mi->getOperand(miOp.index).isKill());*/
+
+      for (auto &op : pair.uses)
+        op.mi->getOperand(op.index).setReg(phyReg);
+
+      for (auto &op : pair.defs)
+        op.mi->getOperand(op.index).setReg(phyReg);
+
+      // Insert the move instr right before the first use instruction.
+      // IDEM
+      // ... = R0
+      // ...
+      // R0 = ...
+      //
+      // to
+      //
+      // IDEM
+      // R2 = R0  [inserted new move instr]
+      // ... = R2
+      // ...
+      // R2 = ...
+      tii->copyPhysReg(*insertedPos->getParent(), insertedPos, DebugLoc(), phyReg, oldReg,
+                       useMO.mi->getOperand(useMO.index).isKill());
 
       // Note that, after replace the old register with new reg, which maybe
       // raise other anti-dependence, such as:
@@ -1433,7 +1670,7 @@ bool IdemRegisterRenamer::handleAntiDependences() {
       // R0 = R3 + R1
       // R2 = ...
       // R3 = ...
-      for (auto &r : regions) {
+      /*for (auto &r : regions) {
         auto &liveIns = gather->getIdemLiveIns(&r->getEntry());
         liveIns.erase(oldReg);
         liveIns.insert(phyReg);
@@ -1446,16 +1683,16 @@ bool IdemRegisterRenamer::handleAntiDependences() {
                              std::vector<MIOp>());
 
         // FIXME Update the live in registers for the region where insertedPos instr resides
-        auto mbb = r->getEntry().getParent();
+        *//*auto mbb = r->getEntry().getParent();
         visited.clear();
         bool seenRedef = false;
         updateLiveInOfPriorRegions(MachineBasicBlock::reverse_iterator(r->getEntry()),
-            mbb->rend(), mbb, visited, pair.reg, seenRedef);
-      }
+            mbb->rend(), mbb, visited, pair.reg, seenRedef);*//*
+      }*/
     }
 
     // Now, replace all old registers used in two addr instr with the new register.
-    if (twoAddrInstExits) {
+    /*if (twoAddrInstExits) {
       auto useMI = pair.uses.back().mi;
       auto moIndex = pair.uses.back().index;
       auto mbb = useMI->getParent();
@@ -1512,24 +1749,27 @@ bool IdemRegisterRenamer::handleAntiDependences() {
         if (mo.isReg() && mo.getReg() == oldReg)
           mo.setReg(phyReg);
       }
-    }
+    }*/
 
     // cope with other anti-dependence pair caused by inserting such move.
-    for (auto itr = antiDeps.begin(), end = antiDeps.end(); itr != end; ++itr) {
+    /*for (auto itr = antiDeps.begin(), end = antiDeps.end(); itr != end; ++itr) {
       AntiDeps ad = *itr;
       if (ad.uses.empty() || ad.defs.empty())
         antiDeps.erase(itr);
       else if (ad.uses.front() == pair.uses.front() && ad.reg == pair.reg) {
         antiDeps.erase(itr); // just remove it.
-        /*for (auto op : ad.uses)
-          op.mi->getOperand(op.index).setReg(phyReg);*/
+        *//*for (auto op : ad.uses)
+          op.mi->getOperand(op.index).setReg(phyReg);*//*
       }
-    }
+    }*/
 
   UPDATE_INTERVAL:
     // FIXME, use an lightweight method to update LiveIntervalAnalysisIdem
     li->releaseMemory();
     li->runOnMachineFunction(*mf);
+    delete gather;
+    gather = new LiveInsGather(*mf);
+    gather->run();
   }
 
   return true;
@@ -1562,7 +1802,8 @@ bool IdemRegisterRenamer::runOnMachineFunction(MachineFunction &MF) {
   llvm::errs() << "Before renaming2: \n";
   MF.dump();
 
-  collectLiveInRegistersForRegions();
+  // Compute liveness for each region.
+  gather->run();
   computeReversePostOrder(MF, reversePostOrderMBBs);
 
   computeAntiDependenceSet();
diff --git a/lib/CodeGen/MachineVerifier.cpp b/lib/CodeGen/MachineVerifier.cpp
index 27daaf2..eb7b256 100644
--- a/lib/CodeGen/MachineVerifier.cpp
+++ b/lib/CodeGen/MachineVerifier.cpp
@@ -1363,7 +1363,7 @@ void MachineVerifier::verifyIdempotentRegions() {
 
   auto savedIdemPreservationMode = IdempotencePreservationMode;
   if (EnableRegisterRenaming)
-    IdempotencePreservationMode = IdempotenceOptions::InvariableCF;
+    IdempotencePreservationMode = IdempotenceOptions::VariableCF;
 
   for (MachineIdempotentRegions::const_iterator R = MIR->begin(),
        RE = MIR->end(); R != RE; ++R) {
diff --git a/lib/CodeGen/IdemRegRename/IdemRegisterRenaming2.cpp b/lib/CodeGen/IdemRegRename/IdemRegisterRenaming2.cpp
index da3e6a4..16a486d 100644
--- a/lib/CodeGen/IdemRegRename/IdemRegisterRenaming2.cpp
+++ b/lib/CodeGen/IdemRegRename/IdemRegisterRenaming2.cpp
@@ -128,7 +128,7 @@ private:
 
   bool isTwoAddressInstr(MachineInstr *useMI);
 
-  void spillCurrentUse(AntiDeps &ad);
+  void spillCurrentUse(AntiDeps &pair);
 
   unsigned choosePhysRegForRenaming(MachineOperand *use,
                                     LiveIntervalIdem *interval,
@@ -206,6 +206,13 @@ private:
                         MachineBasicBlock *mbb,
                         std::set<MachineBasicBlock *> &visited);
 
+  void collectUsesAlongOtherPath(unsigned reg,
+                                 MachineBasicBlock *insertedMBB,
+                                 MachineBasicBlock *firstDefMBB,
+                                 bool &needSpecialHandling,
+                                 std::vector<MIOp> &uses,
+                                 MachineBasicBlock *&otherMBB);
+
 private:
   const TargetInstrInfo *tii;
   const TargetRegisterInfo *tri;
@@ -1152,6 +1159,78 @@ bool IdemRegisterRenamer::willRaiseAntiDep(unsigned useReg,
   return false;
 }
 
+void IdemRegisterRenamer::collectUsesAlongOtherPath(unsigned reg,
+                                                    MachineBasicBlock *insertedMBB,
+                                                    MachineBasicBlock *firstDefMBB,
+                                                    bool &needSpecialHandling,
+                                                    std::vector<MIOp> &uses,
+                                                    MachineBasicBlock *&otherMBB) {
+  std::set<MachineBasicBlock*> visited;
+  MachineBasicBlock *tmp = nullptr;
+  {
+    typedef std::pair<MachineBasicBlock *, MachineBasicBlock *> Item;
+    std::vector<Item> worklist;
+    worklist.emplace_back(firstDefMBB, nullptr);
+
+    while (!worklist.empty()) {
+      MachineBasicBlock *cur = worklist.back().first;
+      MachineBasicBlock *prev = worklist.back().second;
+      worklist.pop_back();
+      if (!visited.insert(cur).second)
+        continue;
+
+      if (cur == insertedMBB) {
+        tmp = prev;
+        break;
+      }
+      std::for_each(cur->pred_begin(), cur->pred_end(), [&](MachineBasicBlock *pred) {
+        worklist.emplace_back(pred, cur);
+      });
+    }
+  }
+
+  if (!tmp) {
+    needSpecialHandling = false;
+    return;
+  }
+
+
+  otherMBB = *insertedMBB->succ_begin() == tmp ?
+      *(++insertedMBB->succ_begin())
+      : *insertedMBB->succ_begin();
+
+  std::vector<MachineBasicBlock*> worklist;
+  visited.clear();
+  worklist.push_back(otherMBB);
+  while (!worklist.empty()) {
+    auto cur = worklist.back();
+    worklist.pop_back();
+    if (!visited.insert(cur).second)
+      continue;
+
+    bool walkDeeply = true;
+    for (auto mi = cur->begin(), end = cur->end(); mi != end; ++mi) {
+      for (int i = 0, e = mi->getNumOperands(); i < e; i++) {
+        auto mo = mi->getOperand(i);
+        if (!mo.isReg() || mo.getReg() != reg)
+          continue;
+
+        if (mo.isDef())
+          walkDeeply = false;
+        else
+          uses.emplace_back(mi, i);
+      }
+    }
+    if (!walkDeeply)
+      continue;
+
+    worklist.insert(worklist.end(), cur->succ_begin(), cur->succ_end());
+  }
+
+  if (!uses.empty())
+    needSpecialHandling = true;
+}
+
 bool IdemRegisterRenamer::handleAntiDependences() {
   if (antiDeps.empty())
     return false;
@@ -1385,40 +1464,76 @@ bool IdemRegisterRenamer::handleAntiDependences() {
        */
       auto miOp = pair.uses.front();
 
-      do {
-        if (shouldSpillCurrent(pair, unallocableRegs, regions)) {
-          spillCurrentUse(pair);
-          goto UPDATE_INTERVAL;
-        }
-
+      // Get a free register using a live interval.
+      {
         LiveIntervalIdem interval;
 
         // indicates this interval should not be spilled out into memory.
         interval.costToSpill = UINT32_MAX;
-
         auto from = li->getIndex(insertedPos) - 2;
         auto to = li->getIndex(pair.uses.back().mi);
-
         interval.addRange(from, to);    // add an interval for a temporal move instr.
-        phyReg = choosePhysRegForRenaming(&miOp.mi->getOperand(miOp.index), &interval, unallocableRegs);
 
-        visited.clear();
-        if (!phyReg)
-          break;
+        do {
+          if (shouldSpillCurrent(pair, unallocableRegs, regions)) {
+            spillCurrentUse(pair);
+            goto UPDATE_INTERVAL;
+          }
+
+          phyReg = choosePhysRegForRenaming(&miOp.mi->getOperand(miOp.index), &interval, unallocableRegs);
 
-        if (!willRaiseAntiDep(phyReg, useMO.mi,
-            useMO.mi->getParent()->end(), useMO.mi->getParent(), visited))
-          break;
+          visited.clear();
+          if (!phyReg)
+            break;
 
-        unallocableRegs.insert(phyReg);
-      }while (true);
+          if (!willRaiseAntiDep(phyReg, useMO.mi,
+                                useMO.mi->getParent()->end(), useMO.mi->getParent(), visited))
+            break;
 
-      if (!phyReg) {
-        spillCurrentUse(pair);
-        goto UPDATE_INTERVAL;
+          unallocableRegs.insert(phyReg);
+        } while (true);
+
+        if (!phyReg) {
+          spillCurrentUse(pair);
+          goto UPDATE_INTERVAL;
+        }
       }
 
+      /*
+       In some cases, we have to extend the live interval til the last use along the
+       different control flow path, fo example:
+
+                 IDEM                             <------ BB9
+                 ...
+              CMPrr R12, R1
+              /            \
+             /             \
+            v              v
+ BB10----> IDEM         R12 = COPY R1             <------ BB29
+  STRrs R12, LR, R2, 16368 /
+             \            /
+              \         /
+               \      /
+                \   /
+                 v v
+                IDEM                              <------ BB11
+
+       We can eliminate the anti-dependence on 'R12' in the region consisting of BB9 and BB29.
+       However, the live ins of BB9 will still contains R12 caused by use of R12 in BB10,
+       so that it will trigger an anti-dependenece along the path from BB0 to BB29 even
+       though there is no 'real' anti-dependence in here. We must cope with this case.
+      */
+      auto insertedMBB = insertedPos->getParent();
+      bool needSpecialHandling = false;
+      std::vector<MIOp> uses;
+      MachineBasicBlock *otherMBB = nullptr;
+      collectUsesAlongOtherPath(pair.reg, insertedMBB,
+          pair.defs.front().mi->getParent(),
+          needSpecialHandling, uses, otherMBB);
+
       assert(insertedPos);
+      if (needSpecialHandling)
+        assert(otherMBB);
 
       // FIXME 10/23/2018
       // li->intervals.insert(std::make_pair(phyReg, interval));
@@ -1436,6 +1551,17 @@ bool IdemRegisterRenamer::handleAntiDependences() {
       tii->copyPhysReg(*insertedPos->getParent(), insertedPos, DebugLoc(), phyReg, oldReg,
                        miOp.mi->getOperand(miOp.index).isKill());
 
+      if (needSpecialHandling) {
+        // TODO speccial handling, 10/25/2018
+        // Insert a store right after prior inserted copy instr
+        const TargetRegisterClass *rc = tri->getMinimalPhysRegClass(pair.reg);
+        int slotFI = mfi->CreateSpillStackObject(rc->getSize(), rc->getAlignment());
+        tii->storeRegToStackSlot(*insertedMBB, insertedPos, pair.reg, true, slotFI, rc, tri);
+
+        // insert load in the position right before the first instruction of otherMBB.
+        tii->loadRegFromStackSlot(*otherMBB, otherMBB->front(), pair.reg, slotFI, rc, tri);
+      }
+
       // Note that, after replace the old register with new reg, which maybe
       // raise other anti-dependence, such as:
       // R0 = R2 + R1
diff --git a/lib/CodeGen/IdemRegRename/IdemRegisterRenaming2.cpp b/lib/CodeGen/IdemRegRename/IdemRegisterRenaming2.cpp
index 334c5ed..d32b32b 100644
--- a/lib/CodeGen/IdemRegRename/IdemRegisterRenaming2.cpp
+++ b/lib/CodeGen/IdemRegRename/IdemRegisterRenaming2.cpp
@@ -48,9 +48,23 @@ struct MIOp {
 
   MIOp(MachineInstr *MI, unsigned Index) : mi(MI), index(Index) {}
 
+  MIOp(const MIOp &rhs) {
+    this->mi = MachineBasicBlock::iterator(*rhs.mi);
+    this->index = rhs.index;
+  }
+
+  MIOp& operator= (const MIOp &rhs) {
+    this->mi = MachineBasicBlock::iterator(*rhs.mi);
+    this->index = rhs.index;
+    return *this;
+  }
+
   bool operator ==(MIOp &rhs) {
     return &*mi == &*rhs.mi && index == rhs.index;
   }
+  bool operator ==(const MIOp &rhs) const {
+    return &*mi == &*rhs.mi && index == rhs.index;
+  }
 };
 
 struct AntiDeps {
@@ -64,6 +78,14 @@ struct AntiDeps {
     uses.insert(uses.end(), Uses.begin(), Uses.end());
     defs.insert(defs.end(), Defs.begin(), Defs.end());
   }
+
+  bool operator==(const AntiDeps &rhs) const {
+    return reg == rhs.reg && uses == rhs.uses && defs == rhs.defs;
+  }
+
+  bool operator==(AntiDeps &rhs) {
+    return reg == rhs.reg && uses == rhs.uses && defs == rhs.defs;
+  }
 };
 
 class IdemRegisterRenamer : public MachineFunctionPass {
@@ -200,6 +222,21 @@ private:
                                   std::set<MachineBasicBlock*> &visited,
                                   unsigned useReg,
                                   bool &seenRedef);
+  bool partialEquals(unsigned reg1, unsigned reg2) {
+    assert(TargetRegisterInfo::isPhysicalRegister(reg1) &&
+        TargetRegisterInfo::isPhysicalRegister(reg2));
+
+    if (reg1 == reg2) return true;
+    for (const unsigned *r = tri->getSubRegisters(reg1); *r; ++r)
+      if (*r == reg2)
+        return true;
+
+    for (const unsigned *r = tri->getSubRegisters(reg2); *r; ++r)
+      if (*r == reg1)
+        return true;
+
+    return false;
+  }
 
   bool willRaiseAntiDep(unsigned useReg,
                         MachineBasicBlock::iterator begin,
@@ -424,27 +461,147 @@ void IdemRegisterRenamer::collectAntiDepsTrace(unsigned reg,
   }
 }
 
+struct MIOpComparator {
+private:
+  LiveIntervalAnalysisIdem *li;
+public:
+  explicit MIOpComparator(LiveIntervalAnalysisIdem *LI) : li(LI) {}
+  bool operator() (const MIOp &lhs, const MIOp &rhs) {
+    unsigned lhsIndex = li->getIndex(lhs.mi), rhsIndex = li->getIndex(rhs.mi);
+    if (lhsIndex < rhsIndex)
+      return true;
+    else if (lhsIndex > rhsIndex)
+      return false;
+    return lhs.index < rhs.index;
+  }
+};
+
+/**
+ * Add such elements of rhs don't exist in res into the res.
+ * @param res
+ * @param rhs
+ */
+static void add(std::vector<MIOp> &res, std::vector<MIOp> &rhs) {
+  for (auto &op : rhs) {
+    if (std::find(res.begin(), res.end(), op) == res.end()) {
+      res.emplace_back(MachineBasicBlock::iterator(*op.mi), op.index);
+    }
+  }
+}
+
 void IdemRegisterRenamer::gatherAntiDeps(MachineInstr *idem) {
   auto liveIns = gather->getIdemLiveIns(idem);
   if (liveIns.empty())
     return;
 
   auto begin = ++MachineBasicBlock::iterator(idem);
+  std::set<MachineBasicBlock*> visited;
   for (auto reg : liveIns) {
-  /*   if (idem->getParent()->getName() == "if.end35"*//* && reg == 61*//*) {
+     /*if (idem->getParent()->getName() == "if.end35" && reg == 61) {
       llvm::errs()<<"LiveIns: [";
       for (auto reg : liveIns)
         llvm::errs()<<tri->getName(reg)<<", ";
       llvm::errs()<<"]\n";
     }*/
-
-    std::set<MachineBasicBlock*> visited;
+     /*auto saved = antiDeps;
+     antiDeps.clear();*/
+     visited.clear();
     // for an iteration of each live-in register, renew the visited set.
     collectAntiDepsTrace(reg, begin, idem->getParent()->end(),
                          idem->getParent(),
                          std::vector<MIOp>(),
                          std::vector<MIOp>(),
                          visited);
+
+    // We need to handle such case that there are many anti-dependencies
+    // pair in the same region in terms of same register along with
+    // different execution paths, for example:
+    //         IDEM
+    //       /     \
+    //      v       v
+    // ...=R0       ...=R0
+    //     \        /
+    //      v      v
+    //    R0 = R0 + 1
+    /*typedef std::vector<size_t> ADIterator;
+    typedef std::vector<ADIterator> JointedADList;
+    JointedADList adList;
+    if (antiDeps.size() > 1) {
+      ADIterator sameLeadingADs;
+      for (size_t i = 0, e = antiDeps.size(); i < e; i++) {
+        sameLeadingADs.clear();
+        for (size_t j = i + 1; j < e; j++) {
+          if (antiDeps[i] == antiDeps[j]) {
+            if (sameLeadingADs.empty())
+              sameLeadingADs.push_back(i);
+            sameLeadingADs.push_back(j);
+          }
+        }
+
+        if (!sameLeadingADs.empty())
+          adList.push_back(sameLeadingADs);
+      }
+
+      // MIOpComparator comparator(li);
+      // std::set<MIOp, MIOpComparator> uses(comparator), defs(comparator);
+      std::vector<AntiDeps> ads;
+
+      for (auto &list : adList) {
+        std::vector<MIOp> uses, defs;
+
+        size_t i = 0, e = list.size();
+        *//*add(uses, antiDeps[list[0]].uses);
+        add(defs, antiDeps[list[0]].defs);*//*
+
+        for (; i < e; i++) {
+          add(uses, antiDeps[list[i]].uses);
+          add(defs, antiDeps[list[i]].defs);
+        }
+
+        ads.emplace_back(reg, uses, defs);
+
+        *//*antiDeps[list[0]].uses = uses;
+        antiDeps[list[0]].defs = defs;*//*
+        *//*(*ad)->uses.clear();
+        (*ad)->defs.clear();
+        (*ad)->uses.insert((*ad)->uses.begin(), uses.begin(), uses.end());
+        (*ad)->defs.insert((*ad)->defs.begin(), defs.begin(), defs.end());*//*
+      }
+
+      for (auto &list : adList) {
+        for (size_t i : list)
+          if (i < antiDeps.size())
+            antiDeps.erase(antiDeps.begin() + i);
+      }
+
+      // Reach here, if we still have anti-dependencies in antiDeps list, we have to spill out it.
+      // FIXME, We should take an high optimized method instead of simplicity spilling it out in the future.
+      if (antiDeps.size() > 1) {
+        std::vector<MIOp> uses, defs;
+
+        for (auto &ad : antiDeps) {
+          add(uses, ad.uses);
+          add(defs, ad.defs);
+          *//*uses.insert(ad.uses.begin(), ad.uses.end());
+          defs.insert(ad.defs.begin(), ad.defs.end());*//*
+        }
+
+        auto &ad = antiDeps.front();
+        ad.uses = uses;
+        ad.defs = defs;
+        *//*ad.uses.clear();
+        ad.defs.clear();
+        ad.uses.insert(ad.uses.end(), uses.begin(), uses.end());
+        ad.defs.insert(ad.defs.end(), defs.begin(), defs.end());*//*
+        spillCurrentUse(ad);
+        antiDeps.clear();
+      }
+
+      antiDeps = saved;
+    }
+    else
+      antiDeps.insert(antiDeps.begin(), saved.begin(), saved.end());
+      */
   }
 }
 
@@ -1258,7 +1415,7 @@ bool IdemRegisterRenamer::willRaiseAntiDep(unsigned useReg,
       return false;
     for (unsigned i = 0, e = begin->getNumOperands(); i < e; i++) {
       auto mo = begin->getOperand(i);
-      if (mo.isReg() && mo.isDef() && mo.getReg() == useReg)
+      if (mo.isReg() && mo.isDef() && partialEquals(mo.getReg(), useReg))
         return true;
     }
   }
@@ -1472,8 +1629,6 @@ bool IdemRegisterRenamer::handleAntiDependences() {
       MachineInstr *insertedPos = nullptr;
       unsigned minIndex = UINT32_MAX;
       insertedPos = nullptr;
-      auto &useMO = pair.uses.front();
-      unsigned phyReg = 0;
       DenseSet<unsigned> unallocableRegs;
 
       for (auto r : regions) {
@@ -1756,6 +1911,19 @@ bool IdemRegisterRenamer::runOnMachineFunction(MachineFunction &MF) {
 
   computeAntiDependenceSet();
 
+  /*for (unsigned i = 10; i < antiDeps.size(); i++)
+  {
+    llvm::errs()<<"Uses: \n";
+    for (auto &op : antiDeps[i].uses)
+      op.mi->dump();
+    llvm::errs()<<"\n";
+
+    llvm::errs()<<"Defs: \n";
+    for (auto &op : antiDeps[i].defs)
+      op.mi->dump();
+    llvm::errs()<<"\n";
+  }
+  exit(0);*/
   bool changed = false;
   changed |= handleAntiDependences();
 
diff --git a/lib/CodeGen/IdemRegRename/IdempotentRegionLiveInsGather.cpp b/lib/CodeGen/IdemRegRename/IdempotentRegionLiveInsGather.cpp
index d52377e..fee0958 100644
--- a/lib/CodeGen/IdemRegRename/IdempotentRegionLiveInsGather.cpp
+++ b/lib/CodeGen/IdemRegRename/IdempotentRegionLiveInsGather.cpp
@@ -20,9 +20,9 @@ void LiveInsGather::run() {
             tri->isNotCountedAsLiveness(mo.getReg())) continue;
         unsigned reg = mo.getReg();
         if (mo.isUse() && !liveKills[&mbb].count(reg))
-          liveGens[&mbb].insert(reg);
+          addRegisterWithSubregs(liveGens[&mbb], reg);
         else
-          liveKills[&mbb].insert(reg);
+          addRegisterWithSubregs(liveKills[&mbb], reg);
       }
     }
   }
@@ -122,9 +122,9 @@ void LiveInsGather::computeIdemLiveIns(const MachineInstr *mi) {
         continue;
 
       if (mo.isDef())
-        liveOuts.erase(mo.getReg());
+        removeRegisterAndSubregs(liveOuts, mo.getReg());
       else
-        liveOuts.insert(mo.getReg());
+        addRegisterWithSubregs(liveOuts, mo.getReg());
     }
   }
 
diff --git a/lib/CodeGen/IdemRegRename/IdempotentRegionLiveInsGather.h b/lib/CodeGen/IdemRegRename/IdempotentRegionLiveInsGather.h
index ac0a864..e551f38 100644
--- a/lib/CodeGen/IdemRegRename/IdempotentRegionLiveInsGather.h
+++ b/lib/CodeGen/IdemRegRename/IdempotentRegionLiveInsGather.h
@@ -46,6 +46,22 @@ public:
 private:
   void computeIdemLiveIns(const MachineInstr *mi);
   void printLiveRegisters(RegSet &regs, bool liveInOrLiveOut = true);
+  void addRegisterWithSubregs(RegSet &set, unsigned reg) {
+    set.insert(reg);
+    if (!TargetRegisterInfo::isStackSlot(reg) &&
+        TargetRegisterInfo::isPhysicalRegister(reg)) {
+      for (const unsigned *r = tri->getSubRegisters(reg); *r; ++r)
+        set.insert(*r);
+    }
+  }
+  void removeRegisterAndSubregs(RegSet &set, unsigned reg) {
+    set.erase(reg);
+    if (!TargetRegisterInfo::isStackSlot(reg) &&
+        TargetRegisterInfo::isPhysicalRegister(reg)) {
+      for (const unsigned *r = tri->getSubRegisters(reg); *r; ++r)
+        set.erase(*r);
+    }
+  }
 };
 }
 
