diff --git a/lib/CodeGen/IdemRegRename/IdemRegisterRenaming2.cpp b/lib/CodeGen/IdemRegRename/IdemRegisterRenaming2.cpp
index 7f25085..056caa2 100644
--- a/lib/CodeGen/IdemRegRename/IdemRegisterRenaming2.cpp
+++ b/lib/CodeGen/IdemRegRename/IdemRegisterRenaming2.cpp
@@ -37,12 +37,6 @@ static cl::opt<bool> EnableIdemTimeStatistic("idem-time-statistic",
                                              cl::init(false),
                                              cl::desc("Enable time statistic in idem renaming"),
                                              cl::Hidden);
-static cl::opt<unsigned> SpilledIntervalThreshold("spilled-interval-threshold",
-                                                  cl::init(30),
-                                                  cl::desc("The threshold of number of spilled intervals "
-                                                           "when considering spilling other interval or "
-                                                           "current interval"),
-                                                  cl::Hidden);
 
 /// @author Jianping Zeng.
 namespace {
@@ -152,6 +146,8 @@ public:
     ml = nullptr;
     antiDeps.clear();
     region2NumAntiDeps.clear();
+    mi2IdemRegionsMap.clear();
+    mi2UnallocableRegsMap.clear();
   }
 
 private:
@@ -179,9 +175,6 @@ private:
   unsigned choosePhysRegForRenaming(MachineOperand *use,
                                     LiveIntervalIdem *interval,
                                     DenseSet<unsigned> &unallocableRegs);
-  /*void filterUnavailableRegs(MachineOperand *use,
-                             BitVector &allocSet,
-                             bool allowsAntiDep);*/
 
   bool legalToReplace(unsigned newReg, unsigned oldReg);
   unsigned tryChooseFreeRegister(LiveIntervalIdem &interval,
@@ -212,16 +205,6 @@ private:
                                  std::vector<LiveIntervalIdem *> &spilledItrs);
   void getAllocableRegs(unsigned useReg, std::set<unsigned> &allocables);
 
-  void revisitSpilledInterval(std::vector<LiveIntervalIdem *> &spilled);
-
-  void processHandledIntervals(std::vector<LiveIntervalIdem *> &handled,
-                               unsigned currentStart);
-  void insertSpillingCodeForInterval(LiveIntervalIdem *spilledItr);
-
-  void assignRegOrStackSlotAtInterval(LiveIntervalIdem *interval,
-                                      std::vector<LiveIntervalIdem *> &handled,
-                                      std::vector<LiveIntervalIdem *> &spilled);
-
   void getUsesSetOfDef(MachineOperand *def,
                        std::vector<MIOp> &usesAndDefs,
                        bool &canReplace);
@@ -371,13 +354,19 @@ private:
     }
   }
 
-  bool numberOfSubLiveIntervalLessThanThreshold(LiveIntervalIdem *interval);
+  void collectIdempotentRegions();
+
+  void collectIdemRegionsByDFS(MachineBasicBlock *mbb,
+                               IdempotentRegion *&regionSaw,
+                               std::set<MachineBasicBlock *> &visited);
+
+  void collectUnallocableRegsForEachMI();
 
 private:
   const TargetInstrInfo *tii;
   const TargetRegisterInfo *tri;
   MachineIdempotentRegions *mir;
-  std::vector<AntiDeps> antiDeps;
+  std::deque<AntiDeps> antiDeps;
   LiveInsGather *gather;
   LiveIntervalAnalysisIdem *li;
   MachineFunction *mf;
@@ -385,6 +374,8 @@ private:
   MachineFrameInfo *mfi;
   MachineDominatorTree *dt;
   MachineLoopInfo *ml;
+  std::map<MachineInstr*, std::vector<IdempotentRegion*>> mi2IdemRegionsMap;
+  std::map<MachineInstr*, DenseSet<unsigned>> mi2UnallocableRegsMap;
 
   /**
    * This map used for recording the number of anti-dependencies for each
@@ -900,23 +891,9 @@ void IdemRegisterRenamer::getAllocableRegs(unsigned useReg, std::set<unsigned> &
 
 // for a group of sub live interval caused by splitting the original live interval.
 // all of sub intervals in the same group have to be assigned a same frame index.
-static unsigned groupId = 1;
 static std::map<LiveIntervalIdem *, unsigned> intervalGrpId;
 static std::map<unsigned, int> grp2FrameIndex;
 
-static unsigned getOrGroupId(std::vector<LiveIntervalIdem *> itrs) {
-  if (itrs.empty())
-    return 0;
-  for (LiveIntervalIdem *itr : itrs) {
-    if (intervalGrpId.count(itr))
-      return intervalGrpId[itr];
-
-    intervalGrpId[itr] = groupId;
-  }
-  ++groupId;
-  return groupId - 1;
-}
-
 static unsigned getOrGroupId(LiveIntervalIdem *itr) {
   assert(itr);
   assert (intervalGrpId.count(itr));
@@ -1001,7 +978,7 @@ void IdemRegisterRenamer::insertSpillingCodeForInterval(LiveIntervalIdem *spille
                              std::vector<MIOp>(),
                              std::vector<MIOp>(), visited);
 
-        // FIXME Update the live in registers for the region where insertedPos instr resides
+        // Update the live in registers for the region where insertedPos instr resides
         auto mbb = r->getEntry().getParent();
         visited.clear();
         bool seenRedef = false;
@@ -1779,44 +1756,47 @@ void IdemRegisterRenamer::countRegistersRaiseAntiDep(MachineBasicBlock::iterator
   }
 }
 
-int m = 0;
-
 bool IdemRegisterRenamer::handleAntiDependences() {
   if (antiDeps.empty())
     return false;
 
-  std::vector<IdempotentRegion *> regions;
+
   while (!antiDeps.empty()) {
-    Timer t;
-    if (EnableIdemTimeStatistic) {
-      t.init("handleAntiDependence");
-      t.startTimer();
-    }
-    /*dbgs()<<m<<"\n";
-    mf->dump();*/
-    ++m;
+
+    dbgs()<<antiDeps.size()<<"\n";
 
     auto pair = antiDeps.front();
-    antiDeps.erase(antiDeps.begin());
+    antiDeps.pop_front();
 
     if (pair.uses.empty() || pair.defs.empty())
       continue;
 
+    Timer t5;
+    t5.init("Get containing regions");
+    t5.startTimer();
+
     auto &useMO = pair.uses.front();
     auto &defMO = pair.defs.back();
-    mir->getRegionsContaining(*useMO.mi, &regions);
+    std::vector<IdempotentRegion *> regions = mi2IdemRegionsMap[useMO.mi];
+    // mir->getRegionsContaining(*useMO.mi, &regions);
 
     bool useOverlapped = useMO.mi->getOperand(useMO.index).getReg() != pair.reg;
     bool defOverlapped = !partialEquals(defMO.mi->getOperand(defMO.index).getReg(), pair.reg);
+    t5.stopTimer();
+
     if (useOverlapped) {
+      Timer t2;
+      t2.init("Use overlapped");
+      t2.startTimer();
+
       //======================================================================================= //
       // Handle the case that uses of different anti-dependence overlap
       //======================================================================================= //
-      std::vector<MIOp>::iterator pos2 = pair.uses.end()-1;
+      std::vector<MIOp>::iterator pos2 = pair.uses.end() - 1;
       if (isTwoAddressInstr(pos2->mi, pair.reg)) {
         MachineBasicBlock::iterator begin = pos2->mi->getParent()->begin(),
             end = pos2->mi->getParent()->end(), prev;
-        for (; begin != end; ++begin){
+        for (; begin != end; ++begin) {
           if (begin == pos2->mi) {
             break;
           }
@@ -1848,11 +1828,26 @@ bool IdemRegisterRenamer::handleAntiDependences() {
             auto copyMI = getPrevMI(insertedPos);
             li->mi2Idx[copyMI] = li->getIndex(pos2->mi) + 1;
             pair.uses.emplace_back(copyMI, 1);
-          }
-          else if (prev->getOperand(1).getReg() == pair.reg) {
+
+            // Incrementally updating the mi2IdemRegionsMap and mi2UnallocableRegsMap
+            if (tii->isIdemBoundary(insertedPos)) {
+              std::vector<IdempotentRegion*> rs = mi2IdemRegionsMap[insertedPos];
+              auto pos = std::find(rs.begin(), rs.end(), &mir->getRegionAtEntry(*insertedPos));
+              if (pos != rs.end())
+                rs.erase(pos);
+
+              mi2IdemRegionsMap[copyMI] = rs;
+            }
+            else
+              mi2IdemRegionsMap[copyMI] = mi2IdemRegionsMap[insertedPos];
+
+            countRegistersRaiseAntiDep(copyMI, copyMI->getParent()->end(),
+                copyMI->getParent(), mi2UnallocableRegsMap[copyMI]);
+          } else if (prev->getOperand(1).getReg() == pair.reg) {
             // Such as,
             // R3 = R0
             // R3 = LDR_PRE R3, R1
+            t2.stopTimer();
             continue;
           }
         }
@@ -1863,14 +1858,15 @@ bool IdemRegisterRenamer::handleAntiDependences() {
         if (op.mi->getOperand(op.index).getReg() != pair.reg) {
           // move the pos to the first modified MIOp.
           ++pos;
-        }
-        else
+        } else
           break;
       }
 
-      if (pos == pair.uses.end())
+      if (pos == pair.uses.end()) {
         // Reach here, it indicates all uses have been replaced. It isn't needed to advance.
+        t2.stopTimer();
         continue;
+      }
 
       if (pos != pair.uses.begin()) {
         // modified [begin, pos)
@@ -1889,7 +1885,7 @@ bool IdemRegisterRenamer::handleAntiDependences() {
 
         if (!unallocableRegs.count(useReg)) {
           unsigned from = li->getIndex(pair.uses.front().mi);
-          unsigned to = li->getIndex((pos-1)->mi);
+          unsigned to = li->getIndex((pos - 1)->mi);
           if (from < to)
             std::swap(from, to);
 
@@ -1925,6 +1921,7 @@ bool IdemRegisterRenamer::handleAntiDependences() {
 
             itrv->reg = useReg;
             li->insertOrCreateInterval(useReg, itrv);
+            t2.stopTimer();
             continue;
           }
         }
@@ -1932,8 +1929,10 @@ bool IdemRegisterRenamer::handleAntiDependences() {
         // delete those modified uses.
         pair.uses.erase(pair.uses.begin(), pos);
         // if all uses have been replaced, just continue to cope with next
-        if (pair.uses.empty())
+        if (pair.uses.empty()) {
+          t2.stopTimer();
           continue;
+        }
       }
 
       pos = pair.defs.begin();
@@ -1947,10 +1946,16 @@ bool IdemRegisterRenamer::handleAntiDependences() {
       // [begin, pos) have been modified.
       pair.defs.erase(pair.defs.begin(), pos);
 
-      if (pair.defs.empty())
+      if (pair.defs.empty()) {
+        t2.stopTimer();
         continue;
+      }
+      t2.stopTimer();
     }
     if (defOverlapped) {
+      Timer t2;
+      t2.init("Def overlapped");
+      t2.startTimer();
       //======================================================================================= //
       // Handle the case that defs of different anti-dependence overlap
       // We don't need to cope with those def registers have replaced in the previous round if exist
@@ -1979,11 +1984,11 @@ bool IdemRegisterRenamer::handleAntiDependences() {
      *     ...
      *    R0=...
      */
-      std::vector<MIOp>::iterator pos2 = pair.uses.end()-1;
+      std::vector<MIOp>::iterator pos2 = pair.uses.end() - 1;
       if (isTwoAddressInstr(pos2->mi, pair.reg)) {
         MachineBasicBlock::iterator begin = pos2->mi->getParent()->begin(),
             end = pos2->mi->getParent()->end(), prev;
-        for (; begin != end; ++begin){
+        for (; begin != end; ++begin) {
           if (begin == pos2->mi) {
             break;
           }
@@ -2015,11 +2020,26 @@ bool IdemRegisterRenamer::handleAntiDependences() {
             auto copyMI = getPrevMI(insertedPos);
             li->mi2Idx[copyMI] = li->getIndex(pos2->mi) + 1;
             pair.uses.emplace_back(copyMI, 1);
-          }
-          else if (prev->getOperand(1).getReg() == pair.reg) {
+
+            // Incrementally updating the mi2IdemRegionsMap and mi2UnallocableRegsMap
+            if (tii->isIdemBoundary(insertedPos)) {
+              std::vector<IdempotentRegion*> rs = mi2IdemRegionsMap[insertedPos];
+              auto pos = std::find(rs.begin(), rs.end(), &mir->getRegionAtEntry(*insertedPos));
+              if (pos != rs.end())
+                rs.erase(pos);
+
+              mi2IdemRegionsMap[copyMI] = rs;
+            }
+            else
+              mi2IdemRegionsMap[copyMI] = mi2IdemRegionsMap[insertedPos];
+
+            countRegistersRaiseAntiDep(copyMI, copyMI->getParent()->end(),
+                                       copyMI->getParent(), mi2UnallocableRegsMap[copyMI]);
+          } else if (prev->getOperand(1).getReg() == pair.reg) {
             // Such as,
             // R3 = R0
             // R3 = LDR_PRE R3, R1
+            t2.stopTimer();
             continue;
           }
         }
@@ -2035,8 +2055,10 @@ bool IdemRegisterRenamer::handleAntiDependences() {
 
       // delete those elements within the range [pos, end)
       pair.defs.erase(pos, pair.defs.end());
-      if (pair.defs.empty())
+      if (pair.defs.empty()) {
+        t2.stopTimer();
         continue;
+      }
 
       // We should insert a extra move instruction right after the last un-replaced operand
       // pointed by pos.
@@ -2061,17 +2083,37 @@ bool IdemRegisterRenamer::handleAntiDependences() {
         }
 
         tii->copyPhysReg(*pos->mi->getParent(), insertedPos, DebugLoc(), destReg, srcReg, true);
-        auto mov = getPrevMI(insertedPos);
-        unsigned index = li->getIndex(itr)-2;
-        li->mi2Idx[mov] = index;
+        auto copyMI = getPrevMI(insertedPos);
+        unsigned index = li->getIndex(itr) - 2;
+        li->mi2Idx[copyMI] = index;
+
+        // Incrementally updating the mi2IdemRegionsMap and mi2UnallocableRegsMap
+        if (tii->isIdemBoundary(insertedPos)) {
+          std::vector<IdempotentRegion*> rs = mi2IdemRegionsMap[insertedPos];
+          auto pos = std::find(rs.begin(), rs.end(), &mir->getRegionAtEntry(*insertedPos));
+          if (pos != rs.end())
+            rs.erase(pos);
+
+          mi2IdemRegionsMap[copyMI] = rs;
+        }
+        else
+          mi2IdemRegionsMap[copyMI] = mi2IdemRegionsMap[insertedPos];
+
+        countRegistersRaiseAntiDep(copyMI, copyMI->getParent()->end(),
+                                   copyMI->getParent(), mi2UnallocableRegsMap[copyMI]);
 
         ++pos2;
         pair.uses.erase(pos, pair.uses.end());
-        pair.uses.emplace_back(mov, 1);
+        pair.uses.emplace_back(copyMI, 1);
         // twoAddrInstExits = false;
       }
+      t2.stopTimer();
     }
 
+    Timer t2;
+    t2.init("Preparation to replace");
+    t2.startTimer();
+
     MachineInstr *intervalEnd = pair.uses.back().mi;
     MIOp &miLastDef = pair.defs.back();
 
@@ -2092,14 +2134,20 @@ bool IdemRegisterRenamer::handleAntiDependences() {
     getUsesSetOfDef(&miLastDef.mi->getOperand(miLastDef.index), usesAndDef, canReplace);
 
     auto saved = miLastDef.mi;
-    std::set<MachineBasicBlock*> visited;
+    std::set<MachineBasicBlock *> visited;
     if (canReplace)
       willRenameCauseOtherAntiDep(++saved, miLastDef.mi->getParent()->end(),
-        miLastDef.mi->getParent(), pair.reg, visited, canReplace);
+                                  miLastDef.mi->getParent(), pair.reg, visited, canReplace);
 
     // If the current reg is used in ret instr, we can't replace it.
     canReplace &= !twoAddrInstExits;
+    t2.stopTimer();
+
     if (canReplace) {
+      Timer t3;
+      t3.init("replace");
+      t3.startTimer();
+
       // We don't replace the name of R0 in ARM and x86 architecture.
       // Because R0 is implicitly used by return instr.
 
@@ -2114,7 +2162,7 @@ bool IdemRegisterRenamer::handleAntiDependences() {
       if (usesAndDef.empty()) {
         auto mbb = miLastDef.mi->getParent();
         mostFarawayMI = &mbb->back();
-        std::vector<MachineBasicBlock*> worklist;
+        std::vector<MachineBasicBlock *> worklist;
         visited.clear();
         std::for_each(mbb->succ_begin(), mbb->succ_end(), [&](MachineBasicBlock *succ) {
           worklist.push_back(succ);
@@ -2176,19 +2224,19 @@ bool IdemRegisterRenamer::handleAntiDependences() {
 
       for (MIOp &op : usesAndDef) {
         auto mbb = op.mi->getParent();
-        std::for_each(mbb->livein_begin(), mbb->livein_end(), [&](unsigned reg){
+        std::for_each(mbb->livein_begin(), mbb->livein_end(), [&](unsigned reg) {
           addRegisterWithSubregs(unallocableRegs, reg);
         });
       }
 
       for (auto itr = begin; itr != end; ++itr) {
         auto mbb = itr->mi->getParent();
-        std::for_each(mbb->livein_begin(), mbb->livein_end(), [&](unsigned reg){
+        std::for_each(mbb->livein_begin(), mbb->livein_end(), [&](unsigned reg) {
           addRegisterWithSubregs(unallocableRegs, reg);
         });
 
-        std::for_each(mbb->pred_begin(), mbb->pred_end(), [&](MachineBasicBlock *pred){
-          std::for_each(pred->livein_begin(), pred->livein_end(), [&](unsigned reg){
+        std::for_each(mbb->pred_begin(), mbb->pred_end(), [&](MachineBasicBlock *pred) {
+          std::for_each(pred->livein_begin(), pred->livein_end(), [&](unsigned reg) {
             addRegisterWithSubregs(unallocableRegs, reg);
           });
         });
@@ -2205,7 +2253,6 @@ bool IdemRegisterRenamer::handleAntiDependences() {
           mo.mi->getOperand(mo.index).setReg(phyReg);
         });
 
-        // FIXME There are little problem, add this interval into LiveIntervalAnalysisIdem
         // Update the internal data structure of live interval analysis
         li->insertOrCreateInterval(phyReg, itrvl);
 
@@ -2232,10 +2279,12 @@ bool IdemRegisterRenamer::handleAntiDependences() {
                                std::vector<MIOp>(),
                                visited);
         }
+        t3.stopTimer();
         continue;
       }
       else
         delete itrvl;
+      t3.stopTimer();
     }
 
     // get the free register
@@ -2245,6 +2294,9 @@ bool IdemRegisterRenamer::handleAntiDependences() {
       if (regions.empty())
         continue;
 
+      Timer t4;
+      t4.init("Preparation for two addr");
+      t4.startTimer();
       // We shouldn't select the free register from the following kinds:
       // 1. live-in registers of current region.
       // 2. live-in registers of prior region (move instr will be inserted at the end of prior region)
@@ -2270,7 +2322,7 @@ bool IdemRegisterRenamer::handleAntiDependences() {
         auto begin = MachineBasicBlock::reverse_iterator(idem);
         visited.clear();
         collectUnallocableRegs(begin, idem.getParent()->rend(),
-            idem.getParent(), visited, unallocableRegs);
+                               idem.getParent(), visited, unallocableRegs);
 
         unsigned index = li->getIndex(&idem);
         if (index < minIndex) {
@@ -2291,6 +2343,8 @@ bool IdemRegisterRenamer::handleAntiDependences() {
         }
       });
 
+      t4.stopTimer();
+
       /**
        * Avoiding repeatedly erase and add anti-dependence like following example.
        * ... = R1
@@ -2307,6 +2361,9 @@ bool IdemRegisterRenamer::handleAntiDependences() {
        *
        * It will repeat the process, we should avoid that situation.
        */
+      Timer t3;
+      t3.init("count anti-dependencies");
+
       auto miOp = pair.uses.front();
       LiveIntervalIdem *interval = new LiveIntervalIdem;
 
@@ -2324,14 +2381,23 @@ bool IdemRegisterRenamer::handleAntiDependences() {
       interval->addRange(from, to);    // add an interval for a temporal move instr.
       if (shouldSpillCurrent(pair.reg, unallocableRegs, regions)) {
         spillCurrentUse(pair);
+        // t3.stopTimer();
         goto UPDATE_INTERVAL;
       }
 
+      t3.startTimer();
+      // unallocableRegs = mi2UnallocableRegsMap[useMO.mi];
       countRegistersRaiseAntiDep(useMO.mi, useMO.mi->getParent()->end(), useMO.mi->getParent(), unallocableRegs);
+      t3.stopTimer();
+      Timer t5;
+      t5.init("Choose physical register");
+      t5.startTimer();
       phyReg = choosePhysRegForRenaming(&miOp.mi->getOperand(miOp.index), interval, unallocableRegs);
+      t5.stopTimer();
 
       if (!phyReg) {
         spillCurrentUse(pair);
+        // t3.stopTimer();
         goto UPDATE_INTERVAL;
       }
 
@@ -2344,8 +2410,23 @@ bool IdemRegisterRenamer::handleAntiDependences() {
         pair.uses[k].mi->getOperand(pair.uses[k].index).setReg(phyReg);
 
       tii->copyPhysReg(*insertedPos->getParent(), insertedPos, DebugLoc(), phyReg, pair.reg, true);
-      auto copy = getPrevMI(insertedPos);
-      li->mi2Idx[copy] = li->getIndex(insertedPos) - 1;
+      auto copyMI = getPrevMI(insertedPos);
+      li->mi2Idx[copyMI] = li->getIndex(insertedPos) - 1;
+
+      // Incrementally updating the mi2IdemRegionsMap and mi2UnallocableRegsMap
+      if (tii->isIdemBoundary(insertedPos)) {
+        std::vector<IdempotentRegion*> rs = mi2IdemRegionsMap[insertedPos];
+        auto pos = std::find(rs.begin(), rs.end(), &mir->getRegionAtEntry(*insertedPos));
+        if (pos != rs.end())
+          rs.erase(pos);
+
+        mi2IdemRegionsMap[copyMI] = rs;
+      }
+      else
+        mi2IdemRegionsMap[copyMI] = mi2IdemRegionsMap[insertedPos];
+
+      countRegistersRaiseAntiDep(copyMI, copyMI->getParent()->end(),
+                                 copyMI->getParent(), mi2UnallocableRegsMap[copyMI]);
 
       // Update the internal data structure of live interval analysis
       li->insertOrCreateInterval(phyReg, interval);
@@ -2372,7 +2453,7 @@ bool IdemRegisterRenamer::handleAntiDependences() {
                              std::vector<MIOp>(),
                              std::vector<MIOp>(), visited);
 
-        // FIXME Update the live in registers for the region where insertedPos instr resides
+        // Update the live in registers for the region where insertedPos instr resides
         auto mbb = r->getEntry().getParent();
         visited.clear();
         bool seenRedef = false;
@@ -2383,6 +2464,10 @@ bool IdemRegisterRenamer::handleAntiDependences() {
 
     // Now, replace all old registers used in two addr instr with the new register.
     if (twoAddrInstExits) {
+      Timer t3;
+      t3.init("Two address instruction");
+      t3.startTimer();
+
       auto useMI = pair.uses.back().mi;
       auto moIndex = pair.uses.back().index;
       auto mbb = useMI->getParent();
@@ -2418,6 +2503,7 @@ bool IdemRegisterRenamer::handleAntiDependences() {
         antiDeps = savedAntiDeps;
         if (causeAntiDep) {
           spillCurrentUse(pair);
+          t3.stopTimer();
           goto UPDATE_INTERVAL;
         }
 
@@ -2432,7 +2518,7 @@ bool IdemRegisterRenamer::handleAntiDependences() {
         addRegisterWithSuperRegs(unallocableRegs, oldReg);
         addRegisterWithSubregs(unallocableRegs, oldReg);
 
-        for (auto & r : regions) {
+        for (auto &r : regions) {
           auto liveins = gather->getIdemLiveIns(&r->getEntry());
           std::for_each(liveins.begin(), liveins.end(), [&](unsigned reg) {
             addRegisterWithSubregs(unallocableRegs, reg);
@@ -2461,6 +2547,7 @@ bool IdemRegisterRenamer::handleAntiDependences() {
         if (!phyReg) {
           spillCurrentUse(pair);
           delete interval;
+          t3.stopTimer();
           goto UPDATE_INTERVAL;
         }
 
@@ -2468,12 +2555,17 @@ bool IdemRegisterRenamer::handleAntiDependences() {
         assert(phyReg != oldReg);
 
         // We must insert move firstly, and than substitute the old reg with new reg.
-        tii->copyPhysReg(*mbb, useMI, DebugLoc(), phyReg,  oldReg, useMI->getOperand(moIndex).isKill());
-        auto copy = getPrevMI(useMI);
-        li->mi2Idx[copy] = li->getIndex(useMI) - 2;
+        tii->copyPhysReg(*mbb, useMI, DebugLoc(), phyReg, oldReg, useMI->getOperand(moIndex).isKill());
+        auto copyMI = getPrevMI(useMI);
+        li->mi2Idx[copyMI] = li->getIndex(useMI) - 2;
+
+        // Incrementally updating the mi2IdemRegionsMap and mi2UnallocableRegsMap
+        mi2IdemRegionsMap[copyMI] = mi2IdemRegionsMap[useMI];
+        countRegistersRaiseAntiDep(copyMI, copyMI->getParent()->end(),
+                                   copyMI->getParent(), mi2UnallocableRegsMap[copyMI]);
 
         for (unsigned k = 0, e = useMI->getNumOperands(); k < e; k++) {
-          MachineOperand& mo = useMI->getOperand(k);
+          MachineOperand &mo = useMI->getOperand(k);
           if (mo.isReg() && mo.getReg() == oldReg)
             mo.setReg(phyReg);
         }
@@ -2481,20 +2573,26 @@ bool IdemRegisterRenamer::handleAntiDependences() {
         // Update the internal data structure of LiveIntervalAnalyisIdem
         LiveIntervalIdem *oldInterval = li->intervals[oldReg];
         assert(oldInterval);
-        oldInterval->split(li, useMI, copy, phyReg);
-      }
-      else {
+        oldInterval->split(li, useMI, copyMI, phyReg);
+      } else {
 
         // Step#8: substitute the old reg with phyReg,
         // and remove other anti-dep on this use.
 
         // We must insert move firstly, and than substitute the old reg with new reg.
         tii->copyPhysReg(*mbb, useMI, DebugLoc(), oldReg, phyReg, true);
-        auto copy = getPrevMI(useMI);
-        unsigned newStart = li->mi2Idx[copy] = li->getIndex(useMI) - 2;
-        li->resetLiveIntervalStart(oldReg, newStart - 2, &copy->getOperand(0));
-        li->buildIntervalForRegister(phyReg, &copy->getOperand(1));
+        auto copyMI = getPrevMI(useMI);
+
+        // Incrementally updating the mi2IdemRegionsMap and mi2UnallocableRegsMap
+        mi2IdemRegionsMap[copyMI] = mi2IdemRegionsMap[useMI];
+        countRegistersRaiseAntiDep(copyMI, copyMI->getParent()->end(),
+                                   copyMI->getParent(), mi2UnallocableRegsMap[copyMI]);
+
+        unsigned newStart = li->mi2Idx[copyMI] = li->getIndex(useMI) - 2;
+        li->resetLiveIntervalStart(oldReg, newStart - 2, &copyMI->getOperand(0));
+        li->buildIntervalForRegister(phyReg, &copyMI->getOperand(1));
       }
+      t3.stopTimer();
     }
 
 UPDATE_INTERVAL:
@@ -2510,12 +2608,48 @@ UPDATE_INTERVAL:
   /*delete gather;
   gather = new LiveInsGather(*mf);
   gather->run();*/
-  if (EnableIdemTimeStatistic)
-    t.stopTimer();
+    continue;
   }
   return true;
 }
 
+void IdemRegisterRenamer::collectIdemRegionsByDFS(MachineBasicBlock *mbb,
+                                                  IdempotentRegion *&regionSaw,
+                                                  std::set<MachineBasicBlock *> &visited) {
+  if (!mbb || visited.count(mbb)) return;
+
+  visited.insert(mbb);
+  for (auto &mi : *mbb) {
+    if (tii->isIdemBoundary(&mi)) {
+      regionSaw = &mir->getRegionAtEntry(mi);
+    }
+    if (regionSaw)
+      mi2IdemRegionsMap[&mi].push_back(regionSaw);
+  }
+
+  std::for_each(mbb->succ_begin(), mbb->succ_end(), [&](MachineBasicBlock *succ) {
+    if (!visited.count(succ))
+      collectIdemRegionsByDFS(succ, regionSaw, visited);
+  });
+}
+
+void IdemRegisterRenamer::collectIdempotentRegions() {
+  IdempotentRegion* region = nullptr;
+  std::set<MachineBasicBlock*> visited;
+  collectIdemRegionsByDFS(&mf->front(), region, visited);
+}
+
+void IdemRegisterRenamer::collectUnallocableRegsForEachMI() {
+  for (auto &mbb : *mf) {
+    for (auto &mi : mbb)
+    {
+      DenseSet<unsigned> unallocableRegs;
+      countRegistersRaiseAntiDep(mi, mi.getParent()->end(), mi.getParent(), unallocableRegs);
+      mi2UnallocableRegsMap[&mi] = unallocableRegs;
+    }
+  }
+}
+
 bool IdemRegisterRenamer::runOnMachineFunction(MachineFunction &MF) {
   // Step#1: Compute the live-in registers set for each idempotence region.
   // Step#2: Handle two address instruction, insert a move instr before it right away.
@@ -2543,6 +2677,8 @@ bool IdemRegisterRenamer::runOnMachineFunction(MachineFunction &MF) {
   // Collects anti-dependences operand pair.
   /*llvm::errs() << "Before renaming2: \n";
   MF.dump();*/
+  collectIdempotentRegions();
+  // collectUnallocableRegsForEachMI();
 
   bool changed = false;
   collectLiveInRegistersForRegions();
diff --git a/patch.txt b/patch.txt
index cebd74a..cb738ca 100644
--- a/patch.txt
+++ b/patch.txt
@@ -1,1048 +0,0 @@
-diff --git a/lib/CodeGen/IdemRegRename/IdemRegisterRenaming2.cpp b/lib/CodeGen/IdemRegRename/IdemRegisterRenaming2.cpp
-index 7790c5e..4c20600 100644
---- a/lib/CodeGen/IdemRegRename/IdemRegisterRenaming2.cpp
-+++ b/lib/CodeGen/IdemRegRename/IdemRegisterRenaming2.cpp
-@@ -110,7 +110,6 @@ public:
-   }
- 
- private:
--  inline void collectLiveInRegistersForRegions();
-   void computeAntiDependenceSet();
-   void gatherAntiDeps(MachineInstr *idem);
-   bool handleAntiDependences();
-@@ -128,7 +127,7 @@ private:
- 
-   bool isTwoAddressInstr(MachineInstr *useMI);
- 
--  void spillCurrentUse(AntiDeps &ad);
-+  void spillCurrentUse(AntiDeps &pair);
- 
-   unsigned choosePhysRegForRenaming(MachineOperand *use,
-                                     LiveIntervalIdem *interval,
-@@ -163,6 +162,13 @@ private:
-                        std::vector<MIOp> &usesAndDefs,
-                        bool &canReplace);
- 
-+  void getUsesSetOfDef(unsigned reg,
-+                       MachineBasicBlock::iterator begin,
-+                       MachineBasicBlock::iterator end,
-+                       MachineBasicBlock *mbb,
-+                       std::set<MachineBasicBlock *> &visited,
-+                       std::vector<MIOp> &usesAndDefs);
-+
-   unsigned getFreeRegisterForRenaming(unsigned useReg,
-                                       LiveIntervalIdem *interval,
-                                       DenseSet<unsigned> unallocableRegs);
-@@ -206,6 +212,8 @@ private:
-                         MachineBasicBlock *mbb,
-                         std::set<MachineBasicBlock *> &visited);
- 
-+  void handleAntiDepWithoutUses(AntiDeps &pair);
-+
- private:
-   const TargetInstrInfo *tii;
-   const TargetRegisterInfo *tri;
-@@ -235,10 +243,6 @@ FunctionPass *llvm::createIdemRegisterRenamerPass() {
-   return new IdemRegisterRenamer();
- }
- 
--void IdemRegisterRenamer::collectLiveInRegistersForRegions() {
--  gather->run();
--}
--
- LLVM_ATTRIBUTE_UNUSED static bool contains(std::vector<MIOp> &set, unsigned reg) {
-   for (auto &mo : set)
-     if (mo.mi->getOperand(mo.index).getReg() == reg)
-@@ -287,6 +291,7 @@ void IdemRegisterRenamer::collectAntiDepsTrace(unsigned reg,
-     if (tii->isIdemBoundary(itr))
-       return;
- 
-+    itr->dump();
-     // iterate over operands from right to left, which means cope with
-     // use oprs firstly, then def regs.
-     for (int i = itr->getNumOperands() - 1; i >= 0; i--) {
-@@ -327,6 +332,13 @@ void IdemRegisterRenamer::gatherAntiDeps(MachineInstr *idem) {
-   if (liveIns.empty())
-     return;
- 
-+  if (idem->getParent()->getName() == "for.body53") {
-+    for (auto reg : liveIns) {
-+      llvm::errs() << tri->getName(reg)<<" ";
-+    }
-+    llvm::errs()<<"\n";
-+  }
-+
-   auto begin = ++MachineBasicBlock::iterator(idem);
-   for (auto reg : liveIns) {
-     // for an iteration of each live-in register, renew the visited set.
-@@ -998,6 +1010,45 @@ void IdemRegisterRenamer::getUsesSetOfDef(MachineOperand *def,
-       mbb->end(), mbb, visited, usesAndDefs, canReplace, false);
- }
- 
-+void IdemRegisterRenamer::getUsesSetOfDef(unsigned reg,
-+                                          MachineBasicBlock::iterator begin,
-+                                          MachineBasicBlock::iterator end,
-+                                          MachineBasicBlock *mbb,
-+                                          std::set<MachineBasicBlock *> &visited,
-+                                          std::vector<MIOp> &usesAndDefs) {
-+  if (!mbb)
-+    return;
-+  if (!visited.insert(mbb).second)
-+    return;
-+
-+  for (; begin != end; ++begin) {
-+    const auto &mi = begin;
-+    if (tii->isIdemBoundary(mi)) {
-+      return;
-+    }
-+
-+    // when walk through operands, use opr first!
-+    for (int i = mi->getNumOperands() - 1; i >= 0; i--) {
-+      auto mo = mi->getOperand(i);
-+      if (!mo.isReg() || !mo.getReg() || mo.getReg() != reg)
-+        continue;
-+        usesAndDefs.push_back(MIOp(mi, i));
-+    }
-+  }
-+
-+  if (!mbb->succ_empty()) {
-+    for (auto succ = mbb->succ_begin(), succEnd = mbb->succ_end(); succ != succEnd; ++succ) {
-+      getUsesSetOfDef(reg,
-+                      (*succ)->begin(),
-+                      (*succ)->end(),
-+                      *succ,
-+                      visited,
-+                      usesAndDefs);
-+    }
-+  }
-+}
-+
-+
- void IdemRegisterRenamer::collectUnallocableRegs(MachineBasicBlock::reverse_iterator begin,
-                                                  MachineBasicBlock::reverse_iterator end,
-                                                  MachineBasicBlock *mbb,
-@@ -1152,6 +1203,152 @@ bool IdemRegisterRenamer::willRaiseAntiDep(unsigned useReg,
-   return false;
- }
- 
-+void IdemRegisterRenamer::handleAntiDepWithoutUses(AntiDeps &pair) {
-+  // Firstly, try to rename if possible. If can not do that, spill out it!
-+  std::vector<IdempotentRegion*> regions;
-+  auto &useMO = pair.uses.front();
-+
-+  mir->getRegionsContaining(*useMO.mi, &regions);
-+
-+  // get the last insertion position of previous adjacent region
-+  // or the position of prior instruction depends on if the current instr
-+  // is a two address instr.
-+  bool twoAddrInstExits = isTwoAddressInstr(pair.uses.back().mi);
-+
-+  // Try to replace the old register name with other register to reduce
-+  // inserted move instruction.
-+  // If we can not find such register, than alter to insert move.
-+
-+  // We just count on such situation that all uses are within the same region
-+  // as the current region.
-+  std::vector<MIOp> usesAndDef;
-+  bool canReplace = false;
-+  auto &miLastDef = pair.defs.back();
-+  getUsesSetOfDef(&miLastDef.mi->getOperand(miLastDef.index), usesAndDef, canReplace);
-+
-+  auto saved = miLastDef.mi;
-+  std::set<MachineBasicBlock*> visited;
-+  if (canReplace)
-+    willRenameCauseOtherAntiDep(++saved, miLastDef.mi->getParent()->end(),
-+                                miLastDef.mi->getParent(), pair.reg, visited, canReplace);
-+
-+  // If the current reg is used in ret instr, we can't replace it.
-+  if (!twoAddrInstExits && canReplace) {
-+    // We don't replace the name of R0 in ARM and x86 architecture.
-+    // Because R0 is implicitly used by return instr.
-+
-+    MachineInstr *mostFarawayMI = nullptr;
-+    for (auto &mo : usesAndDef) {
-+      if (!mostFarawayMI || (&*mo.mi != mostFarawayMI &&
-+          li->getIndex(mo.mi) > li->getIndex(mostFarawayMI)))
-+        mostFarawayMI = mo.mi;
-+    }
-+
-+    // If the last def don't have any uses
-+    if (usesAndDef.empty()) {
-+      auto mbb = miLastDef.mi->getParent();
-+      mostFarawayMI = &mbb->back();
-+      std::vector<MachineBasicBlock*> worklist;
-+      visited.clear();
-+      std::for_each(mbb->succ_begin(), mbb->succ_end(), [&](MachineBasicBlock *succ) {
-+        worklist.push_back(succ);
-+      });
-+
-+      while (!worklist.empty()) {
-+        mbb = worklist.back();
-+        worklist.pop_back();
-+        if (!visited.insert(mbb).second)
-+          continue;
-+
-+        if (!mbb->empty()) {
-+          if (li->getIndex(&mbb->back()) > li->getIndex(mostFarawayMI))
-+            mostFarawayMI = &mbb->back();
-+        }
-+        std::for_each(mbb->succ_begin(), mbb->succ_end(), [&](MachineBasicBlock *succ) {
-+          worklist.push_back(succ);
-+        });
-+      }
-+    }
-+
-+    assert(mostFarawayMI);
-+
-+    auto miDef = pair.defs.front();
-+    unsigned from = li->getIndex(miDef.mi);
-+    unsigned to = li->getIndex(mostFarawayMI);
-+
-+    unsigned phyReg = 0;
-+    {
-+      LiveIntervalIdem itrvl;
-+
-+      // indicates this interval should not be spilled out into memory.
-+      itrvl.costToSpill = UINT32_MAX;
-+      std::vector<MIOp> temps;
-+      temps.assign(pair.defs.begin(), pair.defs.end());
-+
-+      itrvl.addRange(from, to);
-+      for (auto &op : temps) {
-+        MachineInstr *mi = op.mi;
-+        /*mi->dump();*/
-+        itrvl.usePoints.insert(UsePoint(li->getIndex(mi), &mi->getOperand(op.index)));
-+      }
-+
-+      for (auto &op : usesAndDef) {
-+        MachineInstr *mi = op.mi;
-+        itrvl.usePoints.insert(UsePoint(li->getIndex(mi), &mi->getOperand(op.index)));
-+      }
-+
-+      DenseSet<unsigned> unallocableRegs;
-+      unallocableRegs.insert(pair.reg);
-+      for (auto &r : regions) {
-+        set_union(unallocableRegs, gather->getIdemLiveIns(&r->getEntry()));
-+      }
-+
-+      phyReg = getFreeRegisterForRenaming(pair.reg, &itrvl, unallocableRegs);
-+    }
-+
-+    if (phyReg != 0) {
-+      // We have found a free register can be used for replacing the clobber register.
-+      std::for_each(pair.defs.begin(), pair.defs.end(), [=](MIOp &op) {
-+        op.mi->getOperand(op.index).setReg(phyReg);
-+      });
-+      std::for_each(usesAndDef.begin(), usesAndDef.end(), [=](MIOp &mo) {
-+        mo.mi->getOperand(mo.index).setReg(phyReg);
-+      });
-+
-+      // FIXME There are little problem, add this interval into LiveIntervalAnalysisIdem
-+      // Finish replacing, skip following inserting move instr.
-+      li->releaseMemory();
-+      li->runOnMachineFunction(*mf);
-+
-+      // Before:
-+      // 	IDEM
-+      //  R0 = R0 + R1
-+      //  R0 = R0 + 1
-+      //  ret R0
-+      //
-+      // After:
-+      // 	IDEM
-+      //  R2 = R0 + R1
-+      //  R0 = R2 + 1
-+      //  ret R0
-+      //
-+      // The anti-dependence on R0 also remains.
-+      unsigned oldReg = pair.reg;
-+      for (auto &r : regions) {
-+        auto begin = ++MachineBasicBlock::iterator(r->getEntry());
-+        collectAntiDepsTrace(oldReg, begin, r->getEntry().getParent()->end(),
-+                             r->getEntry().getParent(),
-+                             std::vector<MIOp>(),
-+                             std::vector<MIOp>());
-+      }
-+      return;
-+    }
-+  }
-+
-+  // Otherwise, spill it out.
-+  spillCurrentUse(pair);
-+}
-+
- bool IdemRegisterRenamer::handleAntiDependences() {
-   if (antiDeps.empty())
-     return false;
-@@ -1162,13 +1359,13 @@ bool IdemRegisterRenamer::handleAntiDependences() {
-     auto pair = antiDeps.front();
-     antiDeps.erase(antiDeps.begin());
- 
--    if (pair.uses.empty() || pair.defs.empty())
-+    assert(!pair.defs.empty() && "Those anti-dep without redefs shouldn't be counted as anti-dep!");
-+    if (pair.uses.empty()) {
-+      handleAntiDepWithoutUses(pair);
-       continue;
-+    }
- 
-     auto &useMO = pair.uses.front();
--    if (antiDeps.empty()) {
--      useMO.mi->dump();
--    }
-     mir->getRegionsContaining(*useMO.mi, &regions);
- 
-     // get the last insertion position of previous adjacent region
-@@ -1307,9 +1504,9 @@ bool IdemRegisterRenamer::handleAntiDependences() {
-     }
- 
-     // get the free register
--    unsigned phyReg = 0;
-+    //unsigned phyReg = 0;
- 
--    if (!twoAddrInstExits || pair.uses.size() > 1) {
-+    /*if (!twoAddrInstExits || pair.uses.size() > 1)*/ {
-       if (regions.empty())
-         continue;
- 
-@@ -1324,36 +1521,35 @@ bool IdemRegisterRenamer::handleAntiDependences() {
-       // R0, ... = LDR_INC R0  (two address instr)
-       // we should insert a special move instr for two address instr.
-       MachineInstr *insertedPos = nullptr;
--      unsigned minIndex = UINT32_MAX;
--      insertedPos = nullptr;
--      auto &useMO = pair.uses.front();
-+      //unsigned minIndex = UINT32_MAX;
-+      //auto &useMO = pair.uses.front();
-       unsigned phyReg = 0;
-       DenseSet<unsigned> unallocableRegs;
- 
-       for (auto r : regions) {
-         MachineInstr &idem = r->getEntry();
-         set_union(unallocableRegs, gather->getIdemLiveIns(&idem));
--        auto begin = MachineBasicBlock::reverse_iterator(idem);
-+        /*auto begin = MachineBasicBlock::reverse_iterator(idem);
-         visited.clear();
-         collectUnallocableRegs(begin, idem.getParent()->rend(),
--            idem.getParent(), visited, unallocableRegs);
-+            idem.getParent(), visited, unallocableRegs);*/
- 
--        unsigned index = li->getIndex(&idem);
-+        /*unsigned index = li->getIndex(&idem);
-         if (index < minIndex) {
-           minIndex = index;
-           insertedPos = &idem;
--        }
-+        }*/
-       }
- 
-       // can not assign the old register to use mi
-       unallocableRegs.insert(pair.reg);
--      std::for_each(pair.uses.begin(), pair.uses.end(), [&](MIOp &op) {
-+      /*std::for_each(pair.uses.begin(), pair.uses.end(), [&](MIOp &op) {
-         MachineInstr *useMI = op.mi;
-         for (unsigned i = 0, e = useMI->getNumOperands(); i < e; i++)
-           if (useMI->getOperand(i).isReg() && useMI->getOperand(i).getReg() &&
-               useMI->getOperand(i).isDef())
-             unallocableRegs.insert(useMI->getOperand(i).getReg());
--      });
-+      });*/
- 
-       /**
-        * Avoiding repeatedly erase and add anti-dependence like following example.
-@@ -1371,7 +1567,27 @@ bool IdemRegisterRenamer::handleAntiDependences() {
-        *
-        * It will repeat the process, we should avoid that situation.
-        */
--      auto miOp = pair.uses.front();
-+      insertedPos = useMO.mi;
-+      std::vector<MIOp> usesAndDef;
-+      auto &miLastDef = pair.defs.back();
-+
-+      auto mbb = miLastDef.mi->getParent();
-+      visited.clear();
-+      getUsesSetOfDef(pair.reg, ++MachineBasicBlock::iterator(miLastDef.mi),
-+          mbb->end(), mbb, visited, usesAndDef);
-+
-+      MachineInstr* lastMI = usesAndDef.back().mi;
-+      auto from = li->getIndex(useMO.mi) - 2;
-+      auto to = li->getIndex(lastMI);
-+
-+      LiveIntervalIdem interval;
-+      // indicates this interval should not be spilled out into memory.
-+      interval.costToSpill = UINT32_MAX;
-+
-+      interval.addRange(from, to);    // add an interval for a temporal move instr.
-+      phyReg = choosePhysRegForRenaming(&useMO.mi->getOperand(useMO.index), &interval, unallocableRegs);
-+
-+      /*auto miOp = pair.uses.front();
- 
-       do {
-         if (shouldSpillCurrent(pair, unallocableRegs, regions)) {
-@@ -1399,7 +1615,7 @@ bool IdemRegisterRenamer::handleAntiDependences() {
-           break;
- 
-         unallocableRegs.insert(phyReg);
--      }while (true);
-+      }while (true);*/
- 
-       if (!phyReg) {
-         spillCurrentUse(pair);
-@@ -1412,17 +1628,38 @@ bool IdemRegisterRenamer::handleAntiDependences() {
-       // li->intervals.insert(std::make_pair(phyReg, interval));
- 
-       assert(TargetRegisterInfo::isPhysicalRegister(phyReg));
--      miOp = pair.uses.back();
--      unsigned oldReg = miOp.mi->getOperand(miOp.index).getReg();
-+      unsigned oldReg = useMO.mi->getOperand(useMO.index).getReg();
-       assert(phyReg != oldReg);
- 
-       // If there is two addr instr exists in the end of uses list, we just skip it.
--      size_t e = pair.uses.size() - twoAddrInstExits;
-+      /*size_t e = pair.uses.size() - twoAddrInstExits;
-       for (size_t i = 0; i < e; i++)
-         pair.uses[i].mi->getOperand(pair.uses[i].index).setReg(phyReg);
- 
-       tii->copyPhysReg(*insertedPos->getParent(), insertedPos, DebugLoc(), phyReg, oldReg,
--                       miOp.mi->getOperand(miOp.index).isKill());
-+                       miOp.mi->getOperand(miOp.index).isKill());*/
-+
-+      for (auto &op : pair.uses)
-+        op.mi->getOperand(op.index).setReg(phyReg);
-+
-+      for (auto &op : pair.defs)
-+        op.mi->getOperand(op.index).setReg(phyReg);
-+
-+      // Insert the move instr right before the first use instruction.
-+      // IDEM
-+      // ... = R0
-+      // ...
-+      // R0 = ...
-+      //
-+      // to
-+      //
-+      // IDEM
-+      // R2 = R0  [inserted new move instr]
-+      // ... = R2
-+      // ...
-+      // R2 = ...
-+      tii->copyPhysReg(*insertedPos->getParent(), insertedPos, DebugLoc(), phyReg, oldReg,
-+                       useMO.mi->getOperand(useMO.index).isKill());
- 
-       // Note that, after replace the old register with new reg, which maybe
-       // raise other anti-dependence, such as:
-@@ -1433,7 +1670,7 @@ bool IdemRegisterRenamer::handleAntiDependences() {
-       // R0 = R3 + R1
-       // R2 = ...
-       // R3 = ...
--      for (auto &r : regions) {
-+      /*for (auto &r : regions) {
-         auto &liveIns = gather->getIdemLiveIns(&r->getEntry());
-         liveIns.erase(oldReg);
-         liveIns.insert(phyReg);
-@@ -1446,16 +1683,16 @@ bool IdemRegisterRenamer::handleAntiDependences() {
-                              std::vector<MIOp>());
- 
-         // FIXME Update the live in registers for the region where insertedPos instr resides
--        auto mbb = r->getEntry().getParent();
-+        *//*auto mbb = r->getEntry().getParent();
-         visited.clear();
-         bool seenRedef = false;
-         updateLiveInOfPriorRegions(MachineBasicBlock::reverse_iterator(r->getEntry()),
--            mbb->rend(), mbb, visited, pair.reg, seenRedef);
--      }
-+            mbb->rend(), mbb, visited, pair.reg, seenRedef);*//*
-+      }*/
-     }
- 
-     // Now, replace all old registers used in two addr instr with the new register.
--    if (twoAddrInstExits) {
-+    /*if (twoAddrInstExits) {
-       auto useMI = pair.uses.back().mi;
-       auto moIndex = pair.uses.back().index;
-       auto mbb = useMI->getParent();
-@@ -1512,24 +1749,27 @@ bool IdemRegisterRenamer::handleAntiDependences() {
-         if (mo.isReg() && mo.getReg() == oldReg)
-           mo.setReg(phyReg);
-       }
--    }
-+    }*/
- 
-     // cope with other anti-dependence pair caused by inserting such move.
--    for (auto itr = antiDeps.begin(), end = antiDeps.end(); itr != end; ++itr) {
-+    /*for (auto itr = antiDeps.begin(), end = antiDeps.end(); itr != end; ++itr) {
-       AntiDeps ad = *itr;
-       if (ad.uses.empty() || ad.defs.empty())
-         antiDeps.erase(itr);
-       else if (ad.uses.front() == pair.uses.front() && ad.reg == pair.reg) {
-         antiDeps.erase(itr); // just remove it.
--        /*for (auto op : ad.uses)
--          op.mi->getOperand(op.index).setReg(phyReg);*/
-+        *//*for (auto op : ad.uses)
-+          op.mi->getOperand(op.index).setReg(phyReg);*//*
-       }
--    }
-+    }*/
- 
-   UPDATE_INTERVAL:
-     // FIXME, use an lightweight method to update LiveIntervalAnalysisIdem
-     li->releaseMemory();
-     li->runOnMachineFunction(*mf);
-+    delete gather;
-+    gather = new LiveInsGather(*mf);
-+    gather->run();
-   }
- 
-   return true;
-@@ -1562,7 +1802,8 @@ bool IdemRegisterRenamer::runOnMachineFunction(MachineFunction &MF) {
-   llvm::errs() << "Before renaming2: \n";
-   MF.dump();
- 
--  collectLiveInRegistersForRegions();
-+  // Compute liveness for each region.
-+  gather->run();
-   computeReversePostOrder(MF, reversePostOrderMBBs);
- 
-   computeAntiDependenceSet();
-diff --git a/lib/CodeGen/MachineVerifier.cpp b/lib/CodeGen/MachineVerifier.cpp
-index 27daaf2..eb7b256 100644
---- a/lib/CodeGen/MachineVerifier.cpp
-+++ b/lib/CodeGen/MachineVerifier.cpp
-@@ -1363,7 +1363,7 @@ void MachineVerifier::verifyIdempotentRegions() {
- 
-   auto savedIdemPreservationMode = IdempotencePreservationMode;
-   if (EnableRegisterRenaming)
--    IdempotencePreservationMode = IdempotenceOptions::InvariableCF;
-+    IdempotencePreservationMode = IdempotenceOptions::VariableCF;
- 
-   for (MachineIdempotentRegions::const_iterator R = MIR->begin(),
-        RE = MIR->end(); R != RE; ++R) {
-diff --git a/lib/CodeGen/IdemRegRename/IdemRegisterRenaming2.cpp b/lib/CodeGen/IdemRegRename/IdemRegisterRenaming2.cpp
-index da3e6a4..16a486d 100644
---- a/lib/CodeGen/IdemRegRename/IdemRegisterRenaming2.cpp
-+++ b/lib/CodeGen/IdemRegRename/IdemRegisterRenaming2.cpp
-@@ -128,7 +128,7 @@ private:
- 
-   bool isTwoAddressInstr(MachineInstr *useMI);
- 
--  void spillCurrentUse(AntiDeps &ad);
-+  void spillCurrentUse(AntiDeps &pair);
- 
-   unsigned choosePhysRegForRenaming(MachineOperand *use,
-                                     LiveIntervalIdem *interval,
-@@ -206,6 +206,13 @@ private:
-                         MachineBasicBlock *mbb,
-                         std::set<MachineBasicBlock *> &visited);
- 
-+  void collectUsesAlongOtherPath(unsigned reg,
-+                                 MachineBasicBlock *insertedMBB,
-+                                 MachineBasicBlock *firstDefMBB,
-+                                 bool &needSpecialHandling,
-+                                 std::vector<MIOp> &uses,
-+                                 MachineBasicBlock *&otherMBB);
-+
- private:
-   const TargetInstrInfo *tii;
-   const TargetRegisterInfo *tri;
-@@ -1152,6 +1159,78 @@ bool IdemRegisterRenamer::willRaiseAntiDep(unsigned useReg,
-   return false;
- }
- 
-+void IdemRegisterRenamer::collectUsesAlongOtherPath(unsigned reg,
-+                                                    MachineBasicBlock *insertedMBB,
-+                                                    MachineBasicBlock *firstDefMBB,
-+                                                    bool &needSpecialHandling,
-+                                                    std::vector<MIOp> &uses,
-+                                                    MachineBasicBlock *&otherMBB) {
-+  std::set<MachineBasicBlock*> visited;
-+  MachineBasicBlock *tmp = nullptr;
-+  {
-+    typedef std::pair<MachineBasicBlock *, MachineBasicBlock *> Item;
-+    std::vector<Item> worklist;
-+    worklist.emplace_back(firstDefMBB, nullptr);
-+
-+    while (!worklist.empty()) {
-+      MachineBasicBlock *cur = worklist.back().first;
-+      MachineBasicBlock *prev = worklist.back().second;
-+      worklist.pop_back();
-+      if (!visited.insert(cur).second)
-+        continue;
-+
-+      if (cur == insertedMBB) {
-+        tmp = prev;
-+        break;
-+      }
-+      std::for_each(cur->pred_begin(), cur->pred_end(), [&](MachineBasicBlock *pred) {
-+        worklist.emplace_back(pred, cur);
-+      });
-+    }
-+  }
-+
-+  if (!tmp) {
-+    needSpecialHandling = false;
-+    return;
-+  }
-+
-+
-+  otherMBB = *insertedMBB->succ_begin() == tmp ?
-+      *(++insertedMBB->succ_begin())
-+      : *insertedMBB->succ_begin();
-+
-+  std::vector<MachineBasicBlock*> worklist;
-+  visited.clear();
-+  worklist.push_back(otherMBB);
-+  while (!worklist.empty()) {
-+    auto cur = worklist.back();
-+    worklist.pop_back();
-+    if (!visited.insert(cur).second)
-+      continue;
-+
-+    bool walkDeeply = true;
-+    for (auto mi = cur->begin(), end = cur->end(); mi != end; ++mi) {
-+      for (int i = 0, e = mi->getNumOperands(); i < e; i++) {
-+        auto mo = mi->getOperand(i);
-+        if (!mo.isReg() || mo.getReg() != reg)
-+          continue;
-+
-+        if (mo.isDef())
-+          walkDeeply = false;
-+        else
-+          uses.emplace_back(mi, i);
-+      }
-+    }
-+    if (!walkDeeply)
-+      continue;
-+
-+    worklist.insert(worklist.end(), cur->succ_begin(), cur->succ_end());
-+  }
-+
-+  if (!uses.empty())
-+    needSpecialHandling = true;
-+}
-+
- bool IdemRegisterRenamer::handleAntiDependences() {
-   if (antiDeps.empty())
-     return false;
-@@ -1385,40 +1464,76 @@ bool IdemRegisterRenamer::handleAntiDependences() {
-        */
-       auto miOp = pair.uses.front();
- 
--      do {
--        if (shouldSpillCurrent(pair, unallocableRegs, regions)) {
--          spillCurrentUse(pair);
--          goto UPDATE_INTERVAL;
--        }
--
-+      // Get a free register using a live interval.
-+      {
-         LiveIntervalIdem interval;
- 
-         // indicates this interval should not be spilled out into memory.
-         interval.costToSpill = UINT32_MAX;
--
-         auto from = li->getIndex(insertedPos) - 2;
-         auto to = li->getIndex(pair.uses.back().mi);
--
-         interval.addRange(from, to);    // add an interval for a temporal move instr.
--        phyReg = choosePhysRegForRenaming(&miOp.mi->getOperand(miOp.index), &interval, unallocableRegs);
- 
--        visited.clear();
--        if (!phyReg)
--          break;
-+        do {
-+          if (shouldSpillCurrent(pair, unallocableRegs, regions)) {
-+            spillCurrentUse(pair);
-+            goto UPDATE_INTERVAL;
-+          }
-+
-+          phyReg = choosePhysRegForRenaming(&miOp.mi->getOperand(miOp.index), &interval, unallocableRegs);
- 
--        if (!willRaiseAntiDep(phyReg, useMO.mi,
--            useMO.mi->getParent()->end(), useMO.mi->getParent(), visited))
--          break;
-+          visited.clear();
-+          if (!phyReg)
-+            break;
- 
--        unallocableRegs.insert(phyReg);
--      }while (true);
-+          if (!willRaiseAntiDep(phyReg, useMO.mi,
-+                                useMO.mi->getParent()->end(), useMO.mi->getParent(), visited))
-+            break;
- 
--      if (!phyReg) {
--        spillCurrentUse(pair);
--        goto UPDATE_INTERVAL;
-+          unallocableRegs.insert(phyReg);
-+        } while (true);
-+
-+        if (!phyReg) {
-+          spillCurrentUse(pair);
-+          goto UPDATE_INTERVAL;
-+        }
-       }
- 
-+      /*
-+       In some cases, we have to extend the live interval til the last use along the
-+       different control flow path, fo example:
-+
-+                 IDEM                             <------ BB9
-+                 ...
-+              CMPrr R12, R1
-+              /            \
-+             /             \
-+            v              v
-+ BB10----> IDEM         R12 = COPY R1             <------ BB29
-+  STRrs R12, LR, R2, 16368 /
-+             \            /
-+              \         /
-+               \      /
-+                \   /
-+                 v v
-+                IDEM                              <------ BB11
-+
-+       We can eliminate the anti-dependence on 'R12' in the region consisting of BB9 and BB29.
-+       However, the live ins of BB9 will still contains R12 caused by use of R12 in BB10,
-+       so that it will trigger an anti-dependenece along the path from BB0 to BB29 even
-+       though there is no 'real' anti-dependence in here. We must cope with this case.
-+      */
-+      auto insertedMBB = insertedPos->getParent();
-+      bool needSpecialHandling = false;
-+      std::vector<MIOp> uses;
-+      MachineBasicBlock *otherMBB = nullptr;
-+      collectUsesAlongOtherPath(pair.reg, insertedMBB,
-+          pair.defs.front().mi->getParent(),
-+          needSpecialHandling, uses, otherMBB);
-+
-       assert(insertedPos);
-+      if (needSpecialHandling)
-+        assert(otherMBB);
- 
-       // FIXME 10/23/2018
-       // li->intervals.insert(std::make_pair(phyReg, interval));
-@@ -1436,6 +1551,17 @@ bool IdemRegisterRenamer::handleAntiDependences() {
-       tii->copyPhysReg(*insertedPos->getParent(), insertedPos, DebugLoc(), phyReg, oldReg,
-                        miOp.mi->getOperand(miOp.index).isKill());
- 
-+      if (needSpecialHandling) {
-+        // TODO speccial handling, 10/25/2018
-+        // Insert a store right after prior inserted copy instr
-+        const TargetRegisterClass *rc = tri->getMinimalPhysRegClass(pair.reg);
-+        int slotFI = mfi->CreateSpillStackObject(rc->getSize(), rc->getAlignment());
-+        tii->storeRegToStackSlot(*insertedMBB, insertedPos, pair.reg, true, slotFI, rc, tri);
-+
-+        // insert load in the position right before the first instruction of otherMBB.
-+        tii->loadRegFromStackSlot(*otherMBB, otherMBB->front(), pair.reg, slotFI, rc, tri);
-+      }
-+
-       // Note that, after replace the old register with new reg, which maybe
-       // raise other anti-dependence, such as:
-       // R0 = R2 + R1
-diff --git a/lib/CodeGen/IdemRegRename/IdemRegisterRenaming2.cpp b/lib/CodeGen/IdemRegRename/IdemRegisterRenaming2.cpp
-index 334c5ed..d32b32b 100644
---- a/lib/CodeGen/IdemRegRename/IdemRegisterRenaming2.cpp
-+++ b/lib/CodeGen/IdemRegRename/IdemRegisterRenaming2.cpp
-@@ -48,9 +48,23 @@ struct MIOp {
- 
-   MIOp(MachineInstr *MI, unsigned Index) : mi(MI), index(Index) {}
- 
-+  MIOp(const MIOp &rhs) {
-+    this->mi = MachineBasicBlock::iterator(*rhs.mi);
-+    this->index = rhs.index;
-+  }
-+
-+  MIOp& operator= (const MIOp &rhs) {
-+    this->mi = MachineBasicBlock::iterator(*rhs.mi);
-+    this->index = rhs.index;
-+    return *this;
-+  }
-+
-   bool operator ==(MIOp &rhs) {
-     return &*mi == &*rhs.mi && index == rhs.index;
-   }
-+  bool operator ==(const MIOp &rhs) const {
-+    return &*mi == &*rhs.mi && index == rhs.index;
-+  }
- };
- 
- struct AntiDeps {
-@@ -64,6 +78,14 @@ struct AntiDeps {
-     uses.insert(uses.end(), Uses.begin(), Uses.end());
-     defs.insert(defs.end(), Defs.begin(), Defs.end());
-   }
-+
-+  bool operator==(const AntiDeps &rhs) const {
-+    return reg == rhs.reg && uses == rhs.uses && defs == rhs.defs;
-+  }
-+
-+  bool operator==(AntiDeps &rhs) {
-+    return reg == rhs.reg && uses == rhs.uses && defs == rhs.defs;
-+  }
- };
- 
- class IdemRegisterRenamer : public MachineFunctionPass {
-@@ -200,6 +222,21 @@ private:
-                                   std::set<MachineBasicBlock*> &visited,
-                                   unsigned useReg,
-                                   bool &seenRedef);
-+  bool partialEquals(unsigned reg1, unsigned reg2) {
-+    assert(TargetRegisterInfo::isPhysicalRegister(reg1) &&
-+        TargetRegisterInfo::isPhysicalRegister(reg2));
-+
-+    if (reg1 == reg2) return true;
-+    for (const unsigned *r = tri->getSubRegisters(reg1); *r; ++r)
-+      if (*r == reg2)
-+        return true;
-+
-+    for (const unsigned *r = tri->getSubRegisters(reg2); *r; ++r)
-+      if (*r == reg1)
-+        return true;
-+
-+    return false;
-+  }
- 
-   bool willRaiseAntiDep(unsigned useReg,
-                         MachineBasicBlock::iterator begin,
-@@ -424,27 +461,147 @@ void IdemRegisterRenamer::collectAntiDepsTrace(unsigned reg,
-   }
- }
- 
-+struct MIOpComparator {
-+private:
-+  LiveIntervalAnalysisIdem *li;
-+public:
-+  explicit MIOpComparator(LiveIntervalAnalysisIdem *LI) : li(LI) {}
-+  bool operator() (const MIOp &lhs, const MIOp &rhs) {
-+    unsigned lhsIndex = li->getIndex(lhs.mi), rhsIndex = li->getIndex(rhs.mi);
-+    if (lhsIndex < rhsIndex)
-+      return true;
-+    else if (lhsIndex > rhsIndex)
-+      return false;
-+    return lhs.index < rhs.index;
-+  }
-+};
-+
-+/**
-+ * Add such elements of rhs don't exist in res into the res.
-+ * @param res
-+ * @param rhs
-+ */
-+static void add(std::vector<MIOp> &res, std::vector<MIOp> &rhs) {
-+  for (auto &op : rhs) {
-+    if (std::find(res.begin(), res.end(), op) == res.end()) {
-+      res.emplace_back(MachineBasicBlock::iterator(*op.mi), op.index);
-+    }
-+  }
-+}
-+
- void IdemRegisterRenamer::gatherAntiDeps(MachineInstr *idem) {
-   auto liveIns = gather->getIdemLiveIns(idem);
-   if (liveIns.empty())
-     return;
- 
-   auto begin = ++MachineBasicBlock::iterator(idem);
-+  std::set<MachineBasicBlock*> visited;
-   for (auto reg : liveIns) {
--  /*   if (idem->getParent()->getName() == "if.end35"*//* && reg == 61*//*) {
-+     /*if (idem->getParent()->getName() == "if.end35" && reg == 61) {
-       llvm::errs()<<"LiveIns: [";
-       for (auto reg : liveIns)
-         llvm::errs()<<tri->getName(reg)<<", ";
-       llvm::errs()<<"]\n";
-     }*/
--
--    std::set<MachineBasicBlock*> visited;
-+     /*auto saved = antiDeps;
-+     antiDeps.clear();*/
-+     visited.clear();
-     // for an iteration of each live-in register, renew the visited set.
-     collectAntiDepsTrace(reg, begin, idem->getParent()->end(),
-                          idem->getParent(),
-                          std::vector<MIOp>(),
-                          std::vector<MIOp>(),
-                          visited);
-+
-+    // We need to handle such case that there are many anti-dependencies
-+    // pair in the same region in terms of same register along with
-+    // different execution paths, for example:
-+    //         IDEM
-+    //       /     \
-+    //      v       v
-+    // ...=R0       ...=R0
-+    //     \        /
-+    //      v      v
-+    //    R0 = R0 + 1
-+    /*typedef std::vector<size_t> ADIterator;
-+    typedef std::vector<ADIterator> JointedADList;
-+    JointedADList adList;
-+    if (antiDeps.size() > 1) {
-+      ADIterator sameLeadingADs;
-+      for (size_t i = 0, e = antiDeps.size(); i < e; i++) {
-+        sameLeadingADs.clear();
-+        for (size_t j = i + 1; j < e; j++) {
-+          if (antiDeps[i] == antiDeps[j]) {
-+            if (sameLeadingADs.empty())
-+              sameLeadingADs.push_back(i);
-+            sameLeadingADs.push_back(j);
-+          }
-+        }
-+
-+        if (!sameLeadingADs.empty())
-+          adList.push_back(sameLeadingADs);
-+      }
-+
-+      // MIOpComparator comparator(li);
-+      // std::set<MIOp, MIOpComparator> uses(comparator), defs(comparator);
-+      std::vector<AntiDeps> ads;
-+
-+      for (auto &list : adList) {
-+        std::vector<MIOp> uses, defs;
-+
-+        size_t i = 0, e = list.size();
-+        *//*add(uses, antiDeps[list[0]].uses);
-+        add(defs, antiDeps[list[0]].defs);*//*
-+
-+        for (; i < e; i++) {
-+          add(uses, antiDeps[list[i]].uses);
-+          add(defs, antiDeps[list[i]].defs);
-+        }
-+
-+        ads.emplace_back(reg, uses, defs);
-+
-+        *//*antiDeps[list[0]].uses = uses;
-+        antiDeps[list[0]].defs = defs;*//*
-+        *//*(*ad)->uses.clear();
-+        (*ad)->defs.clear();
-+        (*ad)->uses.insert((*ad)->uses.begin(), uses.begin(), uses.end());
-+        (*ad)->defs.insert((*ad)->defs.begin(), defs.begin(), defs.end());*//*
-+      }
-+
-+      for (auto &list : adList) {
-+        for (size_t i : list)
-+          if (i < antiDeps.size())
-+            antiDeps.erase(antiDeps.begin() + i);
-+      }
-+
-+      // Reach here, if we still have anti-dependencies in antiDeps list, we have to spill out it.
-+      // FIXME, We should take an high optimized method instead of simplicity spilling it out in the future.
-+      if (antiDeps.size() > 1) {
-+        std::vector<MIOp> uses, defs;
-+
-+        for (auto &ad : antiDeps) {
-+          add(uses, ad.uses);
-+          add(defs, ad.defs);
-+          *//*uses.insert(ad.uses.begin(), ad.uses.end());
-+          defs.insert(ad.defs.begin(), ad.defs.end());*//*
-+        }
-+
-+        auto &ad = antiDeps.front();
-+        ad.uses = uses;
-+        ad.defs = defs;
-+        *//*ad.uses.clear();
-+        ad.defs.clear();
-+        ad.uses.insert(ad.uses.end(), uses.begin(), uses.end());
-+        ad.defs.insert(ad.defs.end(), defs.begin(), defs.end());*//*
-+        spillCurrentUse(ad);
-+        antiDeps.clear();
-+      }
-+
-+      antiDeps = saved;
-+    }
-+    else
-+      antiDeps.insert(antiDeps.begin(), saved.begin(), saved.end());
-+      */
-   }
- }
- 
-@@ -1258,7 +1415,7 @@ bool IdemRegisterRenamer::willRaiseAntiDep(unsigned useReg,
-       return false;
-     for (unsigned i = 0, e = begin->getNumOperands(); i < e; i++) {
-       auto mo = begin->getOperand(i);
--      if (mo.isReg() && mo.isDef() && mo.getReg() == useReg)
-+      if (mo.isReg() && mo.isDef() && partialEquals(mo.getReg(), useReg))
-         return true;
-     }
-   }
-@@ -1472,8 +1629,6 @@ bool IdemRegisterRenamer::handleAntiDependences() {
-       MachineInstr *insertedPos = nullptr;
-       unsigned minIndex = UINT32_MAX;
-       insertedPos = nullptr;
--      auto &useMO = pair.uses.front();
--      unsigned phyReg = 0;
-       DenseSet<unsigned> unallocableRegs;
- 
-       for (auto r : regions) {
-@@ -1756,6 +1911,19 @@ bool IdemRegisterRenamer::runOnMachineFunction(MachineFunction &MF) {
- 
-   computeAntiDependenceSet();
- 
-+  /*for (unsigned i = 10; i < antiDeps.size(); i++)
-+  {
-+    llvm::errs()<<"Uses: \n";
-+    for (auto &op : antiDeps[i].uses)
-+      op.mi->dump();
-+    llvm::errs()<<"\n";
-+
-+    llvm::errs()<<"Defs: \n";
-+    for (auto &op : antiDeps[i].defs)
-+      op.mi->dump();
-+    llvm::errs()<<"\n";
-+  }
-+  exit(0);*/
-   bool changed = false;
-   changed |= handleAntiDependences();
- 
-diff --git a/lib/CodeGen/IdemRegRename/IdempotentRegionLiveInsGather.cpp b/lib/CodeGen/IdemRegRename/IdempotentRegionLiveInsGather.cpp
-index d52377e..fee0958 100644
---- a/lib/CodeGen/IdemRegRename/IdempotentRegionLiveInsGather.cpp
-+++ b/lib/CodeGen/IdemRegRename/IdempotentRegionLiveInsGather.cpp
-@@ -20,9 +20,9 @@ void LiveInsGather::run() {
-             tri->isNotCountedAsLiveness(mo.getReg())) continue;
-         unsigned reg = mo.getReg();
-         if (mo.isUse() && !liveKills[&mbb].count(reg))
--          liveGens[&mbb].insert(reg);
-+          addRegisterWithSubregs(liveGens[&mbb], reg);
-         else
--          liveKills[&mbb].insert(reg);
-+          addRegisterWithSubregs(liveKills[&mbb], reg);
-       }
-     }
-   }
-@@ -122,9 +122,9 @@ void LiveInsGather::computeIdemLiveIns(const MachineInstr *mi) {
-         continue;
- 
-       if (mo.isDef())
--        liveOuts.erase(mo.getReg());
-+        removeRegisterAndSubregs(liveOuts, mo.getReg());
-       else
--        liveOuts.insert(mo.getReg());
-+        addRegisterWithSubregs(liveOuts, mo.getReg());
-     }
-   }
- 
-diff --git a/lib/CodeGen/IdemRegRename/IdempotentRegionLiveInsGather.h b/lib/CodeGen/IdemRegRename/IdempotentRegionLiveInsGather.h
-index ac0a864..e551f38 100644
---- a/lib/CodeGen/IdemRegRename/IdempotentRegionLiveInsGather.h
-+++ b/lib/CodeGen/IdemRegRename/IdempotentRegionLiveInsGather.h
-@@ -46,6 +46,22 @@ public:
- private:
-   void computeIdemLiveIns(const MachineInstr *mi);
-   void printLiveRegisters(RegSet &regs, bool liveInOrLiveOut = true);
-+  void addRegisterWithSubregs(RegSet &set, unsigned reg) {
-+    set.insert(reg);
-+    if (!TargetRegisterInfo::isStackSlot(reg) &&
-+        TargetRegisterInfo::isPhysicalRegister(reg)) {
-+      for (const unsigned *r = tri->getSubRegisters(reg); *r; ++r)
-+        set.insert(*r);
-+    }
-+  }
-+  void removeRegisterAndSubregs(RegSet &set, unsigned reg) {
-+    set.erase(reg);
-+    if (!TargetRegisterInfo::isStackSlot(reg) &&
-+        TargetRegisterInfo::isPhysicalRegister(reg)) {
-+      for (const unsigned *r = tri->getSubRegisters(reg); *r; ++r)
-+        set.erase(*r);
-+    }
-+  }
- };
- }
- 
